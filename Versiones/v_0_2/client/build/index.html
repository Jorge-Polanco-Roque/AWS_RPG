<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎮 AWS Quest - Pixel Adventure</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="debug.js"></script>
    <style>
        :root {
            /* Pixel Art Color Palette */
            --pixel-blue: #0066ff;
            --pixel-red: #ff0044;
            --pixel-green: #00cc44;
            --pixel-yellow: #ffcc00;
            --pixel-purple: #8844ff;
            --pixel-cyan: #00ffcc;
            --pixel-orange: #ff8800;
            --pixel-pink: #ff44cc;
            
            /* Background Colors */
            --bg-dark: #1a1a2e;
            --bg-darker: #16213e;
            --bg-darkest: #0f0f23;
            
            /* Text Colors */
            --text-white: #ffffff;
            --text-light: #f0f0f0;
            --text-gray: #aaaaaa;
            
            /* Pixel Borders */
            --border-light: #666666;
            --border-dark: #333333;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        body, html {
            width: 100%;
            height: 100vh;
            overflow: hidden;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            line-height: 1.5;
            background: var(--bg-darkest);
            color: var(--text-white);
            user-select: none;
        }

        /* Pixel Art Base Classes */
        .pixel-box {
            border: 2px solid var(--border-light);
            border-top-color: var(--text-white);
            border-left-color: var(--text-white);
            border-right-color: var(--border-dark);
            border-bottom-color: var(--border-dark);
            background: var(--bg-dark);
        }

        .pixel-button {
            border: 2px solid var(--border-light);
            border-top-color: var(--text-white);
            border-left-color: var(--text-white);
            border-right-color: var(--border-dark);
            border-bottom-color: var(--border-dark);
            background: var(--bg-darker);
            color: var(--text-white);
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.1s ease;
            position: relative;
            overflow: hidden;
            z-index: 1000;
            pointer-events: auto;
        }

        .pixel-button:hover {
            background: var(--pixel-blue);
            border-top-color: var(--pixel-cyan);
            border-left-color: var(--pixel-cyan);
            transform: translateY(-1px);
        }

        .pixel-button:active {
            border-top-color: var(--border-dark);
            border-left-color: var(--border-dark);
            border-right-color: var(--text-white);
            border-bottom-color: var(--text-white);
            transform: translateY(1px);
        }

        .pixel-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .pixel-button:hover::before {
            left: 100%;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                font-size: 6px;
            }
            
            .pixel-button {
                font-size: 6px;
                padding: 6px 12px;
            }
            
            .welcome-content {
                width: 95%;
                max-width: none;
            }
            
            .battle-interface {
                flex-direction: column;
                gap: 10px;
            }
            
            .battle-options {
                flex-direction: column;
                gap: 8px;
            }
            
            .battle-option {
                width: 100%;
                min-height: 40px;
                font-size: 6px;
            }
            
            .hud {
                flex-wrap: wrap;
                gap: 5px;
            }
            
            .hud-item {
                min-width: 80px;
                font-size: 6px;
            }
            
            .map-panel {
                width: 95%;
                max-width: none;
            }
            
            .map-grid {
                gap: 5px;
            }
            
            .map-region {
                width: 80px;
                height: 80px;
                font-size: 6px;
            }
            
            /* Mobile Achievement Styles */
            .achievement-notification {
                max-width: 90%;
                padding: 15px;
            }
            
            .achievement-name {
                font-size: 10px;
            }
            
            .achievement-description {
                font-size: 7px;
            }
            
            .progress-panel {
                width: 100%;
                right: -100%;
            }
            
            .progress-button {
                top: 10px;
                right: 10px;
                font-size: 6px;
                padding: 8px 12px;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 480px) {
            body {
                font-size: 5px;
            }
            
            .pixel-button {
                font-size: 5px;
                padding: 4px 8px;
            }
            
            .battle-option {
                min-height: 35px;
                font-size: 5px;
            }
            
            .hud-item {
                min-width: 60px;
                font-size: 5px;
            }
            
            .map-region {
                width: 60px;
                height: 60px;
                font-size: 5px;
            }
            
            /* Ultra-Mobile Achievement Styles */
            .achievement-notification {
                padding: 10px;
            }
            
            .achievement-icon {
                font-size: 24px;
            }
            
            .achievement-name {
                font-size: 8px;
            }
            
            .achievement-description {
                font-size: 6px;
            }
            
            .progress-button {
                font-size: 5px;
                padding: 6px 10px;
            }
        }
        
        /* Enhanced Animations */
        @keyframes slideIn {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: scale(1);
            }
            to {
                opacity: 0;
                transform: scale(0.8);
            }
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }
        
        @keyframes glow {
            0%, 100% {
                box-shadow: 0 0 5px var(--pixel-blue);
            }
            50% {
                box-shadow: 0 0 20px var(--pixel-blue), 0 0 30px var(--pixel-cyan);
            }
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }
        
        @keyframes shake {
            0%, 100% {
                transform: translateX(0);
            }
            10%, 30%, 50%, 70%, 90% {
                transform: translateX(-2px);
            }
            20%, 40%, 60%, 80% {
                transform: translateX(2px);
            }
        }
        
        @keyframes sparkle {
            0%, 100% {
                opacity: 0;
                transform: scale(0) rotate(0deg);
            }
            50% {
                opacity: 1;
                transform: scale(1) rotate(180deg);
            }
        }
        
        @keyframes float {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-5px);
            }
        }
        
        @keyframes pixelExplosion {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(3);
            }
        }
        
        @keyframes levelUp {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            50% {
                transform: translateY(-20px) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translateY(-40px) scale(1.5);
                opacity: 0;
            }
        }
        
        @keyframes correctAnswer {
            0% {
                background: var(--pixel-green);
                transform: scale(1);
            }
            50% {
                background: var(--pixel-cyan);
                transform: scale(1.05);
            }
            100% {
                background: var(--pixel-green);
                transform: scale(1);
            }
        }
        
        @keyframes wrongAnswer {
            0% {
                background: var(--pixel-red);
                transform: translateX(0);
            }
            25% {
                background: var(--pixel-red);
                transform: translateX(-5px);
            }
            75% {
                background: var(--pixel-red);
                transform: translateX(5px);
            }
            100% {
                background: var(--pixel-red);
                transform: translateX(0);
            }
        }
        
        @keyframes comboBuilder {
            0% {
                transform: scale(1);
                color: var(--text-white);
            }
            50% {
                transform: scale(1.2);
                color: var(--pixel-yellow);
            }
            100% {
                transform: scale(1);
                color: var(--pixel-orange);
            }
        }
        
        @keyframes damageNumber {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            50% {
                transform: translateY(-30px) scale(1.3);
                opacity: 1;
            }
            100% {
                transform: translateY(-60px) scale(1.5);
                opacity: 0;
            }
        }
        
        @keyframes healingNumber {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            50% {
                transform: translateY(-20px) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translateY(-40px) scale(1.4);
                opacity: 0;
            }
        }
        
        @keyframes particleFloat {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) rotate(360deg);
                opacity: 0;
            }
        }
        
        @keyframes screenShake {
            0%, 100% {
                transform: translate(0, 0);
            }
            10%, 30%, 50%, 70%, 90% {
                transform: translate(-2px, -2px);
            }
            20%, 40%, 60%, 80% {
                transform: translate(2px, 2px);
            }
        }
        
        @keyframes typewriter {
            from {
                width: 0;
            }
            to {
                width: 100%;
            }
        }
        
        @keyframes blink {
            0%, 50% {
                opacity: 1;
            }
            51%, 100% {
                opacity: 0;
            }
        }
        
        /* Animation Classes */
        .animate-slide-in {
            animation: slideIn 0.5s ease-out forwards;
        }
        
        .animate-slide-out {
            animation: slideOut 0.5s ease-in forwards;
        }
        
        .animate-fade-in {
            animation: fadeIn 0.3s ease-out forwards;
        }
        
        .animate-fade-out {
            animation: fadeOut 0.3s ease-in forwards;
        }
        
        .animate-pulse {
            animation: pulse 2s infinite;
        }
        
        .animate-glow {
            animation: glow 1.5s infinite;
        }
        
        .animate-bounce {
            animation: bounce 1s infinite;
        }
        
        .animate-shake {
            animation: shake 0.5s ease-in-out;
        }
        
        .animate-float {
            animation: float 3s ease-in-out infinite;
        }
        
        .animate-level-up {
            animation: levelUp 1s ease-out forwards;
        }
        
        .animate-correct-answer {
            animation: correctAnswer 0.8s ease-out;
        }
        
        .animate-wrong-answer {
            animation: wrongAnswer 0.6s ease-out;
        }
        
        .animate-combo-builder {
            animation: comboBuilder 0.5s ease-out;
        }
        
        .animate-damage-number {
            animation: damageNumber 1.2s ease-out forwards;
        }
        
        .animate-healing-number {
            animation: healingNumber 1s ease-out forwards;
        }
        
        .animate-particle-float {
            animation: particleFloat 2s linear forwards;
        }
        
        .animate-screen-shake {
            animation: screenShake 0.3s ease-out;
        }
        
        .animate-typewriter {
            animation: typewriter 2s steps(40, end);
        }
        
        .animate-blink {
            animation: blink 1s infinite;
        }
        
        /* Particle System */
        .particle {
            position: absolute;
            pointer-events: none;
            z-index: 9999;
            font-size: 8px;
            color: var(--pixel-cyan);
            user-select: none;
        }
        
        .particle.sparkle {
            animation: sparkle 1s ease-out forwards;
        }
        
        .particle.explosion {
            animation: pixelExplosion 0.8s ease-out forwards;
        }
        
        .particle.float {
            animation: particleFloat 3s linear forwards;
        }
        
        /* Battle Animation Effects */
        .battle-effect {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
            font-size: 16px;
            font-weight: bold;
            color: var(--pixel-yellow);
            text-shadow: 2px 2px 0px var(--bg-darkest);
        }
        
        .battle-effect.damage {
            color: var(--pixel-red);
            animation: damageNumber 1.2s ease-out forwards;
        }
        
        .battle-effect.heal {
            color: var(--pixel-green);
            animation: healingNumber 1s ease-out forwards;
        }
        
        .battle-effect.combo {
            color: var(--pixel-orange);
            animation: comboBuilder 0.5s ease-out;
        }
        
        /* Enhanced Loading Animation */
        .loading-dots {
            display: inline-block;
            position: relative;
            width: 40px;
            height: 10px;
        }
        
        .loading-dots div {
            position: absolute;
            top: 0;
            width: 8px;
            height: 8px;
            background: var(--pixel-cyan);
            border-radius: 50%;
            animation: loadingDots 1.2s linear infinite;
        }
        
        .loading-dots div:nth-child(1) { left: 0; animation-delay: -0.24s; }
        .loading-dots div:nth-child(2) { left: 12px; animation-delay: -0.12s; }
        .loading-dots div:nth-child(3) { left: 24px; animation-delay: 0; }
        
        @keyframes loadingDots {
            0%, 80%, 100% {
                transform: scale(0);
            }
            40% {
                transform: scale(1);
            }
        }
        
        /* Screen Transitions */
        .screen-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-darkest);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
        }
        
        .screen-transition.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .screen-transition-text {
            font-family: 'Press Start 2P', monospace;
            font-size: 16px;
            color: var(--pixel-cyan);
            text-align: center;
            animation: pulse 2s infinite;
        }
        
        /* Enhanced Button Animations */
        .pixel-button {
            position: relative;
            overflow: hidden;
            transition: all 0.2s ease;
        }
        
        .pixel-button:hover {
            animation: glow 1s infinite;
        }
        
        .pixel-button:active {
            animation: shake 0.1s ease-out;
        }
        
        .pixel-button.clicked {
            animation: pulse 0.3s ease-out;
        }
        
        /* Floating UI Elements */
        .floating-element {
            animation: float 3s ease-in-out infinite;
        }
        
        .floating-element.slow {
            animation-duration: 4s;
        }
        
        .floating-element.fast {
            animation-duration: 2s;
        }
        
        /* Breathing Animation for Icons */
        .breathing-icon {
            animation: pulse 2s ease-in-out infinite;
        }
        
        /* Hover Effects for Cards */
        .level-card:hover {
            animation: bounce 0.6s ease-out;
        }
        
        .achievement-card:hover {
            animation: glow 0.5s ease-out;
        }
        
        /* Staggered Animations for Lists */
        .staggered-item {
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 0.6s ease-out forwards;
        }
        
        .staggered-item:nth-child(1) { animation-delay: 0.1s; }
        .staggered-item:nth-child(2) { animation-delay: 0.2s; }
        .staggered-item:nth-child(3) { animation-delay: 0.3s; }
        .staggered-item:nth-child(4) { animation-delay: 0.4s; }
        .staggered-item:nth-child(5) { animation-delay: 0.5s; }
        
        /* Progress Bar Animations */
        .progress-bar {
            position: relative;
            overflow: hidden;
        }
        
        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: progressShine 2s infinite;
        }
        
        @keyframes progressShine {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        /* Glow Effects for Important Elements */
        .glow-effect {
            animation: glow 2s ease-in-out infinite;
        }
        
        .glow-effect.fast {
            animation-duration: 1s;
        }
        
        .glow-effect.slow {
            animation-duration: 3s;
        }
        
        /* Typewriter Effect */
        .typewriter-text {
            overflow: hidden;
            border-right: 2px solid var(--pixel-cyan);
            white-space: nowrap;
            animation: 
                typewriter 3s steps(40, end),
                blink 1s infinite step-end;
        }
        
        /* Particle Container */
        .particle-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }
        
        /* Inventory System Styles */
        .inventory-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.3s ease-out;
        }
        
        .inventory-content {
            background: linear-gradient(135deg, var(--bg-darker), var(--bg-dark));
            border: 3px solid var(--pixel-cyan);
            border-radius: 12px;
            padding: 20px;
            max-width: 800px;
            max-height: 600px;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .inventory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--pixel-cyan);
        }
        
        .inventory-header h2 {
            color: var(--pixel-cyan);
            font-family: 'Press Start 2P', monospace;
            font-size: 16px;
            margin: 0;
        }
        
        .inventory-close {
            color: var(--pixel-red);
            font-size: 24px;
            cursor: pointer;
            transition: color 0.2s;
        }
        
        .inventory-close:hover {
            color: var(--text-white);
        }
        
        .inventory-currency {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            padding: 10px;
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid var(--pixel-cyan);
            border-radius: 8px;
        }
        
        .inventory-currency span {
            color: var(--pixel-yellow);
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
        }
        
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .inventory-item {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 2px solid var(--border-light);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .inventory-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }
        
        .inventory-item.common {
            border-color: #ffffff;
        }
        
        .inventory-item.uncommon {
            border-color: #00ff00;
            background: linear-gradient(135deg, rgba(0, 255, 0, 0.1), rgba(0, 255, 0, 0.05));
        }
        
        .inventory-item.rare {
            border-color: #0066ff;
            background: linear-gradient(135deg, rgba(0, 102, 255, 0.1), rgba(0, 102, 255, 0.05));
        }
        
        .inventory-item.epic {
            border-color: #cc00ff;
            background: linear-gradient(135deg, rgba(204, 0, 255, 0.1), rgba(204, 0, 255, 0.05));
        }
        
        .inventory-item.legendary {
            border-color: #ffcc00;
            background: linear-gradient(135deg, rgba(255, 204, 0, 0.1), rgba(255, 204, 0, 0.05));
            animation: glow 2s infinite;
        }
        
        .item-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }
        
        .item-name {
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            color: var(--text-white);
            margin-bottom: 5px;
        }
        
        .item-quantity {
            font-family: 'Press Start 2P', monospace;
            font-size: 6px;
            color: var(--pixel-yellow);
            position: absolute;
            top: 5px;
            right: 5px;
        }
        
        .inventory-equipped {
            border-top: 2px solid var(--pixel-cyan);
            padding-top: 15px;
        }
        
        .inventory-equipped h3 {
            color: var(--pixel-cyan);
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            margin-bottom: 10px;
        }
        
        .equipped-slots {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .equipped-slot {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid var(--pixel-cyan);
            border-radius: 6px;
            padding: 8px;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            color: var(--text-light);
        }
        
        /* Inventory Button in Menu */
        .inventory-button {
            background: var(--bg-darker);
            border: 2px solid var(--pixel-green);
            border-top-color: var(--text-white);
            border-left-color: var(--text-white);
            border-right-color: var(--border-dark);
            border-bottom-color: var(--border-dark);
            color: var(--text-white);
            padding: 8px 12px;
            font-family: 'Press Start 2P', monospace;
            font-size: 7px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .inventory-button:hover {
            background: var(--pixel-green);
            transform: translateY(-1px);
        }
        
        /* AWS Components Screen */
        .components-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .component-card {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(139, 92, 246, 0.1));
            border: 2px solid var(--pixel-cyan);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .component-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 212, 255, 0.4);
            border-color: var(--pixel-yellow);
        }
        
        .component-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }
        
        .component-card:hover::before {
            left: 100%;
        }
        
        .component-icon {
            font-size: 48px;
            margin-bottom: 15px;
            display: block;
            animation: bounce 2s infinite;
        }
        
        .component-title {
            font-family: 'Press Start 2P', monospace;
            font-size: 14px;
            color: var(--pixel-cyan);
            margin-bottom: 10px;
        }
        
        .component-description {
            font-size: 12px;
            color: var(--text-light);
            line-height: 1.4;
            margin-bottom: 15px;
        }
        
        .component-count {
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            color: var(--pixel-yellow);
            background: rgba(255, 204, 0, 0.1);
            padding: 5px 10px;
            border-radius: 6px;
            display: inline-block;
        }
        
        /* Emoji Battle Characters */
        .battle-emoji {
            font-size: 64px;
            display: inline-block;
            margin: 20px;
            animation: bounce 2s infinite;
        }
        
        .battle-emoji.player {
            animation-delay: 0s;
        }
        
        .battle-emoji.enemy {
            animation-delay: 0.5s;
        }
        
        .battle-emoji:hover {
            animation: bounce 0.5s infinite;
        }
        
        /* Enhanced bounce effect */
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-15px);
            }
            60% {
                transform: translateY(-7px);
            }
        }
        
        @keyframes shake {
            0%, 100% {
                transform: translateX(0);
            }
            25% {
                transform: translateX(-5px);
            }
            75% {
                transform: translateX(5px);
            }
        }
        
        /* Enhanced Notification System */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 8px;
            color: white;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            z-index: 10000;
            animation: slideIn 0.3s ease-out;
            max-width: 320px;
            word-wrap: break-word;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            margin-bottom: 10px;
        }
        
        .notification-icon {
            font-size: 12px;
            flex-shrink: 0;
        }
        
        .notification-text {
            flex: 1;
            line-height: 1.4;
        }
        
        .notification-close {
            cursor: pointer;
            font-size: 12px;
            opacity: 0.7;
            transition: opacity 0.2s;
            flex-shrink: 0;
        }
        
        .notification-close:hover {
            opacity: 1;
        }
        
        .notification.success {
            background: linear-gradient(45deg, var(--pixel-green), #00ff44);
            border: 2px solid #00ff44;
            border-left: 4px solid #00ff88;
        }
        
        .notification.error {
            background: linear-gradient(45deg, var(--pixel-red), #ff4444);
            border: 2px solid #ff4444;
            border-left: 4px solid #ff6666;
        }
        
        .notification.info {
            background: linear-gradient(45deg, var(--pixel-blue), #4444ff);
            border: 2px solid #4444ff;
            border-left: 4px solid #6666ff;
        }
        
        .notification.warning {
            background: linear-gradient(45deg, var(--pixel-yellow), #ffff44);
            border: 2px solid #ffff44;
            border-left: 4px solid #ffff88;
            color: #000;
        }
        
        .notification.fadeOut {
            animation: slideOut 0.3s ease-in;
        }
        
        /* Notification Container */
        #notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }
        
        #notification-container .notification {
            pointer-events: auto;
            position: relative;
            top: auto;
            right: auto;
            margin: 0;
        }
        
        /* Enhanced UI Elements */
        .battle-interface {
            animation: fadeIn 0.5s ease-out;
        }
        
        .battle-option {
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .battle-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .battle-option.selected {
            animation: pulse 0.5s infinite;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.5);
        }
        
        .battle-option.correct {
            animation: pulse 0.3s ease-in-out;
            background: linear-gradient(45deg, var(--pixel-green), #00ff44);
            box-shadow: 0 0 20px rgba(0, 255, 68, 0.6);
        }
        
        .battle-option.incorrect {
            animation: shake 0.3s ease-in-out;
            background: linear-gradient(45deg, var(--pixel-red), #ff4444);
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.6);
        }
        
        .hud {
            animation: fadeIn 0.5s ease-out 0.3s both;
        }
        
        .map-region {
            transition: all 0.3s ease;
            position: relative;
        }
        
        .map-region:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 204, 255, 0.5);
        }
        
        .map-region.current {
            animation: pulse 2s infinite;
            box-shadow: 0 0 25px rgba(0, 204, 255, 0.8);
        }
        
        /* Progress Bars Enhancement */
        .progress-bar {
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            background-size: 50px 100%;
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% {
                background-position: -50px 0;
            }
            100% {
                background-position: 100% 0;
            }
        }
        
        /* Enhanced Button States */
        .pixel-button.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(50%);
        }
        
        .pixel-button:not(.disabled):hover {
            filter: brightness(1.1);
        }
        
        .pixel-button:not(.disabled):active {
            filter: brightness(0.9);
        }
        
        /* Achievement Badge */
        .achievement-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--pixel-yellow);
            color: var(--bg-darkest);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 6px;
            font-weight: bold;
            z-index: 100;
        }
        
        /* Progress Ring Animation */
        .progress-ring {
            position: relative;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid var(--border-dark);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: var(--text-white);
        }
        
        .progress-ring::after {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 3px solid transparent;
            border-top-color: var(--pixel-cyan);
            animation: spin 2s linear infinite;
        }
        
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
        
        /* Enhanced Loading States */
        .loading {
            position: relative;
            overflow: hidden;
            opacity: 0.8;
        }
        
        .loading::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 204, 255, 0.6), transparent);
            animation: loading 1.5s infinite;
        }
        
        @keyframes loading {
            0% {
                left: -100%;
            }
            100% {
                left: 100%;
            }
        }
        
        /* Pulse Effect for Important Elements */
        .pulse-glow {
            animation: pulseGlow 2s infinite;
        }
        
        @keyframes pulseGlow {
            0%, 100% {
                box-shadow: 0 0 5px rgba(0, 204, 255, 0.5);
            }
            50% {
                box-shadow: 0 0 20px rgba(0, 204, 255, 0.8), 0 0 30px rgba(0, 204, 255, 0.6);
            }
        }
        
        /* Floating Animation for UI Elements */
        .floating {
            animation: floating 3s ease-in-out infinite;
        }
        
        @keyframes floating {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-10px);
            }
        }
        
        /* Achievement System Styles */
        .achievement-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: linear-gradient(135deg, var(--bg-darker), var(--bg-dark));
            border: 3px solid var(--pixel-cyan);
            border-radius: 12px;
            padding: 20px;
            font-family: 'Press Start 2P', monospace;
            color: var(--text-white);
            z-index: 10001;
            opacity: 0;
            transition: all 0.5s ease;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 204, 255, 0.6);
        }
        
        .achievement-notification.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
        
        .achievement-notification.common {
            border-color: var(--pixel-green);
            box-shadow: 0 0 30px rgba(0, 255, 68, 0.6);
        }
        
        .achievement-notification.uncommon {
            border-color: var(--pixel-blue);
            box-shadow: 0 0 30px rgba(0, 102, 255, 0.6);
        }
        
        .achievement-notification.rare {
            border-color: var(--pixel-purple);
            box-shadow: 0 0 30px rgba(136, 68, 255, 0.6);
        }
        
        .achievement-notification.epic {
            border-color: var(--pixel-orange);
            box-shadow: 0 0 30px rgba(255, 136, 0, 0.6);
        }
        
        .achievement-notification.legendary {
            border-color: var(--pixel-yellow);
            box-shadow: 0 0 30px rgba(255, 204, 0, 0.8);
            animation: legendaryGlow 2s infinite;
        }
        
        @keyframes legendaryGlow {
            0%, 100% {
                box-shadow: 0 0 30px rgba(255, 204, 0, 0.8);
            }
            50% {
                box-shadow: 0 0 50px rgba(255, 204, 0, 1), 0 0 80px rgba(255, 204, 0, 0.6);
            }
        }
        
        .achievement-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .achievement-icon {
            font-size: 32px;
            display: inline-block;
            animation: bounce 0.8s ease-in-out;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-15px);
            }
            60% {
                transform: translateY(-8px);
            }
        }
        
        .achievement-title {
            font-size: 10px;
            color: var(--pixel-cyan);
            text-transform: uppercase;
        }
        
        .achievement-name {
            font-size: 12px;
            color: var(--text-white);
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .achievement-description {
            font-size: 8px;
            color: var(--text-gray);
            line-height: 1.4;
            margin-bottom: 15px;
        }
        
        .achievement-rarity {
            font-size: 6px;
            padding: 4px 8px;
            border-radius: 4px;
            display: inline-block;
            font-weight: bold;
        }
        
        .achievement-notification.common .achievement-rarity {
            background: var(--pixel-green);
            color: var(--bg-darkest);
        }
        
        .achievement-notification.uncommon .achievement-rarity {
            background: var(--pixel-blue);
            color: var(--text-white);
        }
        
        .achievement-notification.rare .achievement-rarity {
            background: var(--pixel-purple);
            color: var(--text-white);
        }
        
        .achievement-notification.epic .achievement-rarity {
            background: var(--pixel-orange);
            color: var(--text-white);
        }
        
        .achievement-notification.legendary .achievement-rarity {
            background: var(--pixel-yellow);
            color: var(--bg-darkest);
        }
        
        /* Progress Panel Styles */
        .progress-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: linear-gradient(135deg, var(--bg-darker), var(--bg-dark));
            border-left: 3px solid var(--pixel-cyan);
            transition: right 0.5s ease;
            z-index: 9999;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .progress-panel.active {
            right: 0;
        }
        
        .progress-panel h3 {
            color: var(--pixel-cyan);
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .progress-section {
            margin-bottom: 30px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .progress-bar-container {
            width: 100%;
            height: 20px;
            background: var(--bg-darkest);
            border: 2px solid var(--border-light);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--pixel-cyan), var(--pixel-blue));
            transition: width 0.5s ease;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-label {
            font-size: 6px;
            color: var(--text-gray);
            margin-bottom: 5px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 10px;
            color: var(--pixel-cyan);
            font-weight: bold;
        }
        
        .recent-achievements {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .achievement-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border-left: 4px solid var(--pixel-green);
        }
        
        .achievement-item.uncommon {
            border-left-color: var(--pixel-blue);
        }
        
        .achievement-item.rare {
            border-left-color: var(--pixel-purple);
        }
        
        .achievement-item.epic {
            border-left-color: var(--pixel-orange);
        }
        
        .achievement-item.legendary {
            border-left-color: var(--pixel-yellow);
        }
        
        .achievement-item .achievement-icon {
            font-size: 16px;
            flex-shrink: 0;
        }
        
        .achievement-info {
            flex: 1;
        }
        
        .achievement-item .achievement-name {
            font-size: 8px;
            color: var(--text-white);
            margin-bottom: 4px;
        }
        
        .achievement-item .achievement-desc {
            font-size: 6px;
            color: var(--text-gray);
            line-height: 1.3;
        }
        
        /* Progress Button */
        .progress-button {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            background: var(--pixel-cyan);
            color: var(--bg-darkest);
            border: none;
            padding: 10px 15px;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        
        .progress-button:hover {
            background: var(--pixel-blue);
            transform: scale(1.05);
        }
        
        /* Challenge and Mini-Game System Styles */
        .challenge-panel {
            position: fixed;
            top: 0;
            left: -500px;
            width: 500px;
            height: 100vh;
            background: linear-gradient(135deg, var(--bg-darker), var(--bg-dark));
            border-right: 3px solid var(--pixel-orange);
            transition: left 0.5s ease;
            z-index: 9998;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .challenge-panel.active {
            left: 0;
        }
        
        .challenge-panel h3 {
            color: var(--pixel-orange);
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 2px solid var(--pixel-orange);
            padding-bottom: 10px;
        }
        
        .challenge-item, .mini-game-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            margin-bottom: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .challenge-item:hover, .mini-game-item:hover {
            border-color: var(--pixel-orange);
            background: rgba(255, 136, 0, 0.1);
        }
        
        .challenge-item.completed {
            opacity: 0.6;
            border-color: var(--pixel-green);
        }
        
        .challenge-icon, .mini-game-icon {
            font-size: 32px;
            flex-shrink: 0;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }
        
        .challenge-info, .mini-game-info {
            flex: 1;
        }
        
        .challenge-name, .mini-game-name {
            font-size: 10px;
            color: var(--text-white);
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .challenge-description, .mini-game-description {
            font-size: 7px;
            color: var(--text-gray);
            line-height: 1.4;
            margin-bottom: 8px;
        }
        
        .challenge-reward, .mini-game-high-score {
            font-size: 6px;
            color: var(--pixel-yellow);
            font-weight: bold;
        }
        
        .challenge-hud {
            position: fixed;
            top: 80px;
            left: 20px;
            background: linear-gradient(135deg, var(--bg-darker), var(--bg-dark));
            border: 2px solid var(--pixel-orange);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            color: var(--text-white);
            z-index: 9999;
            display: none;
        }
        
        .challenge-hud.active {
            display: block;
            animation: slideIn 0.5s ease;
        }
        
        .challenge-hud h4 {
            color: var(--pixel-orange);
            margin-bottom: 10px;
            font-size: 9px;
        }
        
        .challenge-progress {
            color: var(--pixel-cyan);
            margin-bottom: 8px;
        }
        
        .challenge-timer {
            color: var(--pixel-red);
            font-weight: bold;
        }
        
        .mini-game-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            height: 500px;
            background: linear-gradient(135deg, var(--bg-darker), var(--bg-dark));
            border: 3px solid var(--pixel-cyan);
            border-radius: 12px;
            padding: 20px;
            z-index: 10000;
            display: none;
            box-shadow: 0 0 50px rgba(0, 204, 255, 0.8);
        }
        
        .mini-game-panel.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }
        
        .mini-game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--pixel-cyan);
        }
        
        .mini-game-title {
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            color: var(--pixel-cyan);
        }
        
        .mini-game-close {
            background: var(--pixel-red);
            color: var(--text-white);
            border: none;
            padding: 8px 12px;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            cursor: pointer;
            border-radius: 4px;
        }
        
        .mini-game-content {
            height: 400px;
            overflow-y: auto;
        }
        
        /* Service Matcher Styles */
        .service-matcher-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: 100%;
        }
        
        .services-column, .descriptions-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .service-card, .description-card {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--border-light);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Press Start 2P', monospace;
            font-size: 7px;
        }
        
        .service-card:hover, .description-card:hover {
            border-color: var(--pixel-cyan);
            background: rgba(0, 204, 255, 0.1);
        }
        
        .service-card.selected, .description-card.selected {
            border-color: var(--pixel-yellow);
            background: rgba(255, 204, 0, 0.2);
        }
        
        .service-card.matched, .description-card.matched {
            border-color: var(--pixel-green);
            background: rgba(0, 255, 68, 0.2);
            opacity: 0.6;
            pointer-events: none;
        }
        
        .service-icon {
            font-size: 20px;
            width: 30px;
            text-align: center;
        }
        
        .service-name {
            font-weight: bold;
            color: var(--text-white);
        }
        
        .service-description {
            color: var(--text-gray);
            line-height: 1.4;
        }
        
        .game-stats {
            text-align: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid var(--border-light);
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            color: var(--pixel-cyan);
        }
        
        /* Snake Game Styles */
        .snake-game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .snake-score {
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            color: var(--pixel-green);
        }
        
        #snake-canvas {
            border: 3px solid var(--pixel-green);
            border-radius: 8px;
            background: var(--bg-darkest);
        }
        
        .snake-controls {
            text-align: center;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            color: var(--text-gray);
        }
        
        .control-instructions {
            margin-bottom: 8px;
        }
        
        .snake-food {
            color: var(--pixel-yellow);
        }
        
        /* Challenge Button */
        .challenge-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            background: var(--pixel-orange);
            color: var(--bg-darkest);
            border: none;
            padding: 10px 15px;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        
        .challenge-button:hover {
            background: var(--pixel-red);
            transform: scale(1.05);
        }
        
        /* Emergency Reset Button */
        .reset-button {
            position: fixed;
            bottom: 20px;
            right: 140px;
            z-index: 10000;
            background: var(--pixel-red);
            color: var(--text-white);
            border: none;
            padding: 8px 12px;
            font-family: 'Press Start 2P', monospace;
            font-size: 6px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
            opacity: 0.7;
        }
        
        .reset-button:hover {
            background: var(--pixel-orange);
            transform: scale(1.05);
            opacity: 1;
        }
        
        /* Game Menu Bar */
        .game-menu-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: linear-gradient(135deg, var(--bg-darker), var(--bg-dark));
            border-bottom: 3px solid var(--pixel-cyan);
            z-index: 10001;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .menu-left, .menu-right {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .menu-center {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .game-title {
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            color: var(--pixel-cyan);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .menu-button {
            background: var(--bg-darker);
            border: 2px solid var(--border-light);
            border-top-color: var(--text-white);
            border-left-color: var(--text-white);
            border-right-color: var(--border-dark);
            border-bottom-color: var(--border-dark);
            color: var(--text-white);
            padding: 8px 12px;
            font-family: 'Press Start 2P', monospace;
            font-size: 7px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .menu-button:hover {
            background: var(--pixel-blue);
            border-top-color: var(--pixel-cyan);
            border-left-color: var(--pixel-cyan);
            transform: translateY(-1px);
        }
        
        .menu-button:active {
            border-top-color: var(--border-dark);
            border-left-color: var(--border-dark);
            border-right-color: var(--text-white);
            border-bottom-color: var(--text-white);
            transform: translateY(1px);
        }
        
        .audio-toggle, .music-toggle, .sfx-toggle {
            background: var(--bg-darker);
            border: 2px solid var(--border-light);
            color: var(--text-white);
            padding: 6px 10px;
            font-family: 'Press Start 2P', monospace;
            font-size: 6px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        
        .audio-toggle:hover, .music-toggle:hover, .sfx-toggle:hover {
            background: var(--pixel-blue);
            transform: translateY(-1px);
        }
        
        /* Adjust other elements to account for menu bar */
        .ui-overlay {
            top: 50px;
        }
        
        .challenge-button {
            bottom: 70px;
        }
        
        .progress-button {
            top: 70px;
        }
        
        .challenge-hud {
            top: 130px;
        }
        
        @media (max-width: 768px) {
            .game-menu-bar {
                height: 45px;
                padding: 0 10px;
            }
            
            .game-title {
                font-size: 10px;
            }
            
            .menu-button {
                font-size: 6px;
                padding: 6px 10px;
            }
            
            .audio-toggle, .music-toggle, .sfx-toggle {
                font-size: 5px;
                padding: 4px 8px;
            }
            
            .menu-left, .menu-right {
                gap: 5px;
            }
        }
        
        @media (max-width: 480px) {
            .game-menu-bar {
                height: 40px;
                padding: 0 8px;
            }
            
            .game-title {
                font-size: 8px;
            }
            
            .menu-button {
                font-size: 5px;
                padding: 4px 8px;
            }
            
            .audio-toggle, .music-toggle, .sfx-toggle {
                font-size: 4px;
                padding: 3px 6px;
            }
        }
        
        /* Responsive Challenge System */
        @media (max-width: 768px) {
            .challenge-panel {
                width: 100%;
                left: -100%;
            }
            
            .mini-game-panel {
                width: 95%;
                height: 80%;
            }
            
            .challenge-hud {
                font-size: 6px;
                padding: 10px;
            }
            
            .service-matcher-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 480px) {
            .challenge-item, .mini-game-item {
                flex-direction: column;
                text-align: center;
            }
            
            .challenge-icon, .mini-game-icon {
                font-size: 24px;
                width: 40px;
                height: 40px;
            }
            
            .challenge-name, .mini-game-name {
                font-size: 8px;
            }
            
            .challenge-description, .mini-game-description {
                font-size: 6px;
            }
            
            #snake-canvas {
                width: 300px;
                height: 300px;
            }
        }
        
        /* Pixel Game Canvas */
        #game-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            background: linear-gradient(45deg, var(--bg-darkest) 0%, var(--bg-darker) 50%, var(--bg-dark) 100%);
        }
        
        /* Achievement Progress Integration */
        .hud .achievement-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background: var(--pixel-yellow);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: var(--bg-darkest);
            animation: pulse 2s infinite;
        }
        
        .level-progress-enhanced {
            position: relative;
            overflow: hidden;
        }
        
        .level-progress-enhanced::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 204, 255, 0.3), transparent);
            animation: progressShine 3s infinite;
        }
        
        @keyframes progressShine {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }

        /* UI Overlay */
        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .ui-overlay > * {
            pointer-events: auto;
        }

        /* Pixel Game HUD */
        .game-hud {
            position: absolute;
            top: 8px;
            left: 8px;
            right: 8px;
            height: 48px;
            background: var(--bg-dark);
            border: 2px solid var(--border-light);
            border-top-color: var(--text-white);
            border-left-color: var(--text-white);
            border-right-color: var(--border-dark);
            border-bottom-color: var(--border-dark);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 16px;
        }

        /* Pixel Health/Mana Bars */
        .pixel-bar {
            width: 64px;
            height: 8px;
            background: var(--border-dark);
            border: 1px solid var(--border-light);
            position: relative;
            margin: 2px 0;
        }

        .pixel-bar-fill {
            height: 100%;
            background: var(--pixel-green);
            transition: width 0.3s linear;
        }

        .pixel-bar-fill.hp { background: var(--pixel-red); }
        .pixel-bar-fill.mp { background: var(--pixel-blue); }
        .pixel-bar-fill.exp { background: var(--pixel-yellow); }

        /* Welcome Screen Pixel Art */
        .pixel-welcome-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-darkest);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1;
        }

        .pixel-welcome-screen.hidden {
            display: none;
        }

        .pixel-title-box {
            padding: 32px;
            margin-bottom: 32px;
            text-align: center;
        }

        .pixel-title {
            font-size: 24px;
            color: var(--pixel-yellow);
            margin-bottom: 16px;
            text-shadow: 2px 2px 0px var(--border-dark);
        }

        .pixel-subtitle {
            font-size: 12px;
            color: var(--pixel-cyan);
            text-shadow: 1px 1px 0px var(--border-dark);
        }

        .pixel-menu {
            display: flex;
            flex-direction: column;
            gap: 16px;
            align-items: center;
            z-index: 1000;
            position: relative;
        }

        .pixel-menu .pixel-button {
            width: 200px;
            padding: 12px 24px;
            font-size: 10px;
            text-align: center;
            z-index: 1001;
            pointer-events: auto;
            position: relative;
            background: #0066ff !important;
            color: white !important;
            border: 2px solid #ffffff !important;
            cursor: pointer !important;
        }

        .pixel-menu .pixel-button:hover {
            background: #0052cc !important;
            transform: translateY(-2px) !important;
        }

        /* Game HUD Pixel Style */
        .pixel-hud {
            position: absolute;
            top: 60px;
            left: 8px;
            right: 8px;
            height: 64px;
            background: var(--bg-dark);
            border: 2px solid var(--border-light);
            border-top-color: var(--text-white);
            border-left-color: var(--text-white);
            border-right-color: var(--border-dark);
            border-bottom-color: var(--border-dark);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 16px;
            font-size: 8px;
        }

        .pixel-character {
            width: 32px;
            height: 32px;
            background: var(--pixel-blue);
            border: 1px solid var(--text-white);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            margin-right: 16px;
        }

        .pixel-stats {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .pixel-stat-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 8px;
        }

        .pixel-stat-label {
            width: 32px;
            color: var(--text-light);
        }

        /* Battle Interface Pixel Art */
        .pixel-battle-screen {
            position: absolute;
            bottom: 8px;
            left: 8px;
            right: 8px;
            height: 200px;
            background: var(--bg-dark);
            border: 2px solid var(--border-light);
            border-top-color: var(--text-white);
            border-left-color: var(--text-white);
            border-right-color: var(--border-dark);
            border-bottom-color: var(--border-dark);
            padding: 16px;
            display: none;
        }

        .pixel-battle-screen.active {
            display: block;
        }

        .pixel-question {
            background: var(--bg-darker);
            border: 1px solid var(--border-light);
            padding: 8px;
            margin-bottom: 16px;
            font-size: 8px;
            line-height: 1.4;
        }

        .pixel-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .pixel-option {
            background: var(--bg-darker);
            border: 2px solid var(--border-light);
            border-top-color: var(--text-white);
            border-left-color: var(--text-white);
            border-right-color: var(--border-dark);
            border-bottom-color: var(--border-dark);
            padding: 8px;
            font-size: 8px;
            color: var(--text-white);
            cursor: pointer;
            transition: none;
        }

        .pixel-option:hover {
            background: var(--pixel-blue);
        }

        .pixel-option.selected {
            background: var(--pixel-yellow);
            color: var(--bg-darkest);
        }

        .pixel-option.correct {
            background: var(--pixel-green);
            border-color: var(--pixel-green);
        }

        .pixel-option.incorrect {
            background: var(--pixel-red);
            border-color: var(--pixel-red);
        }

        /* Level Selection Screen */
        .pixel-level-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-darkest);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }

        .pixel-level-screen.active {
            display: flex;
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin: 32px 0;
        }

        .level-card {
            width: 200px;
            height: 120px;
            background: var(--bg-dark);
            border: 2px solid var(--border-light);
            border-top-color: var(--text-white);
            border-left-color: var(--text-white);
            border-right-color: var(--border-dark);
            border-bottom-color: var(--border-dark);
            padding: 16px;
            cursor: pointer;
            transition: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .level-card:hover {
            background: var(--pixel-blue);
        }

        .level-card.locked {
            background: var(--border-dark);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .level-title {
            font-size: 10px;
            color: var(--pixel-yellow);
            margin-bottom: 8px;
        }

        .level-description {
            font-size: 8px;
            color: var(--text-light);
            line-height: 1.2;
        }

        .level-stats {
            font-size: 8px;
            color: var(--pixel-cyan);
            margin-top: 8px;
        }

        /* Enhanced HUD */
        .pixel-level-indicator {
            position: absolute;
            top: 80px;
            left: 8px;
            background: var(--bg-dark);
            border: 2px solid var(--border-light);
            border-top-color: var(--text-white);
            border-left-color: var(--text-white);
            border-right-color: var(--border-dark);
            border-bottom-color: var(--border-dark);
            padding: 8px 16px;
            font-size: 8px;
            color: var(--pixel-yellow);
        }

        /* Animations */
        @keyframes pixelPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .pixel-pulse {
            animation: pixelPulse 1s infinite;
        }

        @keyframes pixelShake {
            0%, 100% { transform: translate(0); }
            25% { transform: translate(2px, 2px); }
            50% { transform: translate(-2px, 2px); }
            75% { transform: translate(2px, -2px); }
        }

        .pixel-shake {
            animation: pixelShake 0.3s;
        }

        /* Special Abilities Panel */
        .abilities-panel {
            position: absolute;
            top: 80px;
            right: 8px;
            width: 200px;
            background: var(--bg-dark);
            border: 2px solid var(--border-light);
            border-top-color: var(--text-white);
            border-left-color: var(--text-white);
            border-right-color: var(--border-dark);
            border-bottom-color: var(--border-dark);
            padding: 8px;
            display: none;
        }

        .abilities-panel.active {
            display: block;
        }

        .ability-button {
            width: 100%;
            margin-bottom: 4px;
            padding: 8px;
            font-size: 8px;
            background: var(--bg-darker);
            border: 1px solid var(--border-light);
            color: var(--text-white);
            cursor: pointer;
            transition: none;
        }

        .ability-button:hover:not(.disabled) {
            background: var(--pixel-blue);
        }

        .ability-button.disabled {
            background: var(--border-dark);
            color: var(--text-gray);
            cursor: not-allowed;
        }

        .ability-cost {
            float: right;
            color: var(--pixel-cyan);
        }

        /* Combo System */
        .combo-display {
            position: absolute;
            top: 150px;
            left: 8px;
            background: var(--bg-dark);
            border: 2px solid var(--border-light);
            border-top-color: var(--text-white);
            border-left-color: var(--text-white);
            border-right-color: var(--border-dark);
            border-bottom-color: var(--border-dark);
            padding: 8px 16px;
            font-size: 8px;
            color: var(--pixel-yellow);
            display: none;
        }

        .combo-display.active {
            display: block;
        }

        .combo-number {
            font-size: 12px;
            color: var(--pixel-orange);
        }

        /* Timer Display */
        .timer-display {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--bg-dark);
            border: 2px solid var(--border-light);
            border-top-color: var(--text-white);
            border-left-color: var(--text-white);
            border-right-color: var(--border-dark);
            border-bottom-color: var(--border-dark);
            padding: 8px 16px;
            font-size: 10px;
            color: var(--pixel-red);
            display: none;
        }

        .timer-display.active {
            display: block;
        }

        .timer-warning {
            animation: pixelPulse 0.5s infinite;
            color: var(--pixel-red);
        }

        /* Battle Type Indicators */
        .battle-type-indicator {
            position: absolute;
            top: 200px;
            left: 8px;
            background: var(--bg-dark);
            border: 2px solid var(--border-light);
            border-top-color: var(--text-white);
            border-left-color: var(--text-white);
            border-right-color: var(--border-dark);
            border-bottom-color: var(--border-dark);
            padding: 8px 16px;
            font-size: 8px;
            display: none;
        }

        .battle-type-indicator.active {
            display: block;
        }

        .battle-type-normal { color: var(--text-white); }
        .battle-type-boss { color: var(--pixel-red); }
        .battle-type-speed { color: var(--pixel-yellow); }
        .battle-type-endurance { color: var(--pixel-green); }

        .hud-left {
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        .character-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-blue), var(--secondary-purple));
            border: 3px solid var(--accent-gold);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .character-stats {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .stat-bar {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .stat-label {
            font-size: 0.875rem;
            color: var(--text-muted);
            min-width: 60px;
        }

        .progress-bar {
            width: 150px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-blue), var(--secondary-purple));
            transition: width 0.5s ease;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.8);
        }

        .hp-fill {
            background: linear-gradient(90deg, var(--danger-red), #fbbf24);
        }

        .mp-fill {
            background: linear-gradient(90deg, var(--secondary-purple), var(--primary-blue));
        }

        .hud-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.5rem;
        }
        
        .pixel-level, .pixel-score, .pixel-progress {
            font-size: 10px;
            font-weight: bold;
            color: var(--text-white);
        }
        
        .pixel-progress {
            color: var(--pixel-cyan);
            font-size: 8px;
        }

        .level-display {
            background: linear-gradient(135deg, var(--accent-gold), #f59e0b);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: bold;
            font-family: 'Orbitron', monospace;
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .score-display {
            font-family: 'Orbitron', monospace;
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--primary-blue);
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.8);
        }

        /* Battle UI */
        .battle-interface {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 300px;
            background: linear-gradient(0deg, rgba(10, 10, 15, 0.98) 0%, rgba(10, 10, 15, 0.85) 100%);
            backdrop-filter: blur(15px);
            border-top: 2px solid var(--border-glow);
            display: none;
            flex-direction: column;
            justify-content: space-between;
            padding: 1.5rem;
            box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.8);
        }

        .battle-interface.active {
            display: flex;
        }

        .question-display {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(0, 212, 255, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            backdrop-filter: blur(10px);
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .question-meta {
            display: flex;
            justify-content: space-between;
            margin-bottom: 1rem;
            font-size: 0.875rem;
            color: var(--text-muted);
        }

        .difficulty-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
        }

        .diff-easy { background: rgba(16, 185, 129, 0.2); color: var(--success-green); }
        .diff-medium { background: rgba(251, 191, 36, 0.2); color: var(--accent-gold); }
        .diff-hard { background: rgba(239, 68, 68, 0.2); color: var(--danger-red); }

        .question-text {
            font-size: 1.6rem;
            line-height: 1.9;
            color: var(--text-light);
            margin-bottom: 1.5rem;
            padding: 25px;
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(139, 92, 246, 0.1));
            border: 2px solid rgba(0, 212, 255, 0.3);
            border-radius: 12px;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.2);
        }

        .battle-options {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }

        .battle-option {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(139, 92, 246, 0.1));
            border: 2px solid rgba(0, 212, 255, 0.3);
            border-radius: 12px;
            padding: 2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 1rem;
            position: relative;
            overflow: hidden;
            font-size: 1.3rem;
            line-height: 1.6;
            min-height: 90px;
        }

        .battle-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .battle-option:hover::before {
            left: 100%;
        }

        .battle-option:hover {
            border-color: var(--primary-blue);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.4);
            transform: translateY(-2px);
        }

        .battle-option.selected {
            border-color: var(--accent-gold);
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.2), rgba(245, 158, 11, 0.2));
            box-shadow: 0 0 25px rgba(251, 191, 36, 0.6);
        }

        .battle-option.correct {
            border-color: var(--success-green);
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.3), rgba(5, 150, 105, 0.3));
            box-shadow: 0 0 25px rgba(16, 185, 129, 0.6);
        }

        .battle-option.incorrect {
            border-color: var(--danger-red);
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.3), rgba(220, 38, 38, 0.3));
            box-shadow: 0 0 25px rgba(239, 68, 68, 0.6);
        }

        .option-letter {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-blue), var(--secondary-purple));
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-family: 'Orbitron', monospace;
            flex-shrink: 0;
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
        }

        .option-text {
            flex: 1;
            font-size: 1rem;
            line-height: 1.4;
        }

        /* Action Buttons */
        .battle-actions {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }

        .rpg-button {
            background: linear-gradient(135deg, var(--primary-blue), var(--secondary-purple));
            border: none;
            border-radius: 12px;
            padding: 1rem 2rem;
            font-size: 1rem;
            font-weight: bold;
            font-family: 'Orbitron', monospace;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0, 212, 255, 0.4);
        }

        .rpg-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.4s ease;
            transform: translate(-50%, -50%);
        }

        .rpg-button:hover::before {
            width: 300px;
            height: 300px;
        }

        .rpg-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(0, 212, 255, 0.6);
        }

        .rpg-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #4b5563, #6b7280);
            box-shadow: 0 8px 25px rgba(75, 85, 99, 0.4);
        }

        .btn-secondary:hover {
            box-shadow: 0 12px 35px rgba(75, 85, 99, 0.6);
        }

        /* Inventory Panel */
        .inventory-panel {
            position: absolute;
            top: 100px;
            right: 20px;
            width: 300px;
            background: rgba(10, 10, 15, 0.95);
            border: 2px solid var(--border-glow);
            border-radius: 16px;
            padding: 1.5rem;
            backdrop-filter: blur(15px);
            display: none;
            box-shadow: var(--shadow-heavy);
        }

        .inventory-panel.active {
            display: block;
        }

        .panel-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--primary-blue);
            margin-bottom: 1rem;
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.8);
        }

        /* Map System */
        .map-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 280px;
            height: 250px;
            background: rgba(10, 10, 15, 0.95);
            border: 2px solid var(--border-glow);
            border-radius: 16px;
            padding: 1rem;
            backdrop-filter: blur(15px);
            box-shadow: var(--shadow-heavy);
        }

        .map-title {
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            color: var(--primary-blue);
            margin-bottom: 1rem;
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.8);
        }

        .map-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            height: 140px;
            margin-bottom: 1rem;
        }

        .map-region {
            background: linear-gradient(45deg, var(--bg-darker), var(--secondary-purple));
            border: 1px solid var(--border-glow);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.7rem;
            text-align: center;
            padding: 4px;
            position: relative;
        }

        .map-region:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--primary-blue);
        }

        .map-region.current {
            background: linear-gradient(45deg, var(--accent-gold), var(--primary-blue));
            border-color: var(--accent-gold);
            box-shadow: 0 0 20px var(--accent-gold);
        }

        .map-region.unlocked {
            background: linear-gradient(45deg, var(--secondary-purple), var(--primary-blue));
        }

        .map-region.locked {
            background: linear-gradient(45deg, var(--bg-darker), #333);
            color: var(--text-muted);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .region-icon {
            font-size: 1.2rem;
            margin-bottom: 2px;
        }

        .exploration-progress {
            margin-top: 1rem;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-darker);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 0.5rem;
            border: 1px solid var(--border-glow);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-blue), var(--accent-gold));
            transition: width 0.5s ease;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .inventory-slot {
            aspect-ratio: 1;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .inventory-slot:hover {
            border-color: var(--primary-blue);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.4);
        }

        .inventory-slot.occupied {
            background: linear-gradient(135deg, var(--accent-gold), #f59e0b);
            border-color: var(--accent-gold);
        }

        .item-icon {
            font-size: 1.5rem;
            filter: drop-shadow(0 0 5px rgba(251, 191, 36, 0.8));
        }

        /* Character Stats Panel */
        .stats-panel {
            position: absolute;
            top: 100px;
            left: 20px;
            width: 280px;
            background: rgba(10, 10, 15, 0.95);
            border: 2px solid var(--border-glow);
            border-radius: 16px;
            padding: 1.5rem;
            backdrop-filter: blur(15px);
            display: none;
            box-shadow: var(--shadow-heavy);
        }

        .stats-panel.active {
            display: block;
        }

        .character-portrait {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-blue), var(--secondary-purple));
            border: 3px solid var(--accent-gold);
            margin: 0 auto 1rem auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            box-shadow: 0 0 25px rgba(0, 212, 255, 0.6);
        }

        .character-name {
            text-align: center;
            font-family: 'Orbitron', monospace;
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--accent-gold);
            margin-bottom: 1rem;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-name {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .stat-value {
            color: var(--text-light);
            font-weight: bold;
            font-family: 'Orbitron', monospace;
        }

        /* Welcome Screen */
        .welcome-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, var(--bg-darker) 0%, var(--bg-dark) 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }

        .welcome-screen.hidden {
            display: none;
        }

        .game-logo {
            font-family: 'Orbitron', monospace;
            font-size: 4rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--primary-blue), var(--secondary-purple), var(--accent-gold));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            margin-bottom: 1rem;
            text-shadow: 0 0 30px rgba(0, 212, 255, 0.8);
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { filter: drop-shadow(0 0 20px rgba(0, 212, 255, 0.8)); }
            to { filter: drop-shadow(0 0 40px rgba(139, 92, 246, 0.8)); }
        }

        .game-subtitle {
            font-size: 1.5rem;
            color: var(--text-muted);
            text-align: center;
            margin-bottom: 3rem;
            max-width: 600px;
        }

        .welcome-actions {
            display: flex;
            gap: 2rem;
        }

        /* Particle Effects */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--primary-blue);
            border-radius: 50%;
            opacity: 0.7;
            animation: float 8s ease-in-out infinite;
            box-shadow: 0 0 10px var(--primary-blue);
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) translateX(0px); opacity: 0.7; }
            25% { transform: translateY(-100px) translateX(50px); opacity: 1; }
            50% { transform: translateY(-50px) translateX(-75px); opacity: 0.5; }
            75% { transform: translateY(-150px) translateX(25px); opacity: 0.8; }
        }

        /* Damage/Heal Numbers */
        .damage-number {
            position: absolute;
            font-family: 'Orbitron', monospace;
            font-weight: bold;
            font-size: 2rem;
            z-index: 15;
            pointer-events: none;
            animation: damageFloat 2s ease-out forwards;
        }

        .damage {
            color: var(--danger-red);
            text-shadow: 0 0 10px var(--danger-red);
        }

        .heal {
            color: var(--success-green);
            text-shadow: 0 0 10px var(--success-green);
        }

        .experience {
            color: var(--accent-gold);
            text-shadow: 0 0 10px var(--accent-gold);
        }

        @keyframes damageFloat {
            0% {
                transform: translateY(0px) scale(0.5);
                opacity: 1;
            }
            50% {
                transform: translateY(-50px) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) scale(1);
                opacity: 0;
            }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .pixel-welcome-screen {
                padding: 2rem 1rem;
            }
            
            .pixel-title {
                font-size: 24px;
                margin-bottom: 12px;
            }
            
            .pixel-subtitle {
                font-size: 10px;
                margin-bottom: 24px;
            }
            
            .pixel-menu {
                gap: 12px;
            }
            
            .pixel-button {
                padding: 10px 20px;
                font-size: 10px;
            }
            
            .pixel-hud {
                height: 80px;
                padding: 0 1rem;
            }
            
            .hud-left {
                gap: 1rem;
            }
            
            .pixel-character {
                font-size: 24px;
            }
            
            .pixel-stat-row {
                margin-bottom: 4px;
            }
            
            .pixel-bar {
                width: 80px;
                height: 8px;
            }
            
            .pixel-battle-screen {
                height: 280px;
                padding: 1rem;
            }
            
            .pixel-question {
                font-size: 10px;
                margin-bottom: 16px;
            }
            
            .pixel-options {
                gap: 8px;
            }
            
            .pixel-option {
                padding: 12px;
                font-size: 8px;
            }
            
            .level-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .level-card {
                padding: 12px;
            }
            
            .level-title {
                font-size: 10px;
            }
            
            .level-description {
                font-size: 8px;
            }
        }

        @media (max-width: 480px) {
            .pixel-title {
                font-size: 20px;
            }
            
            .pixel-hud {
                height: 60px;
                padding: 0 0.5rem;
            }
            
            .pixel-battle-screen {
                height: 240px;
                padding: 0.5rem;
            }
            
            .pixel-question {
                font-size: 9px;
                margin-bottom: 12px;
            }
            
            .pixel-option {
                padding: 8px;
                font-size: 7px;
            }
            
            .pixel-bar {
                width: 60px;
                height: 6px;
            }
        }

        /* Smooth Animations */
        .pixel-option {
            transition: all 0.2s ease;
        }

        .pixel-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 102, 255, 0.3);
        }

        .pixel-option.selected {
            transform: translateY(-1px);
            animation: pulse 0.6s ease-in-out;
        }

        @keyframes pulse {
            0% { transform: scale(1) translateY(-1px); }
            50% { transform: scale(1.05) translateY(-1px); }
            100% { transform: scale(1) translateY(-1px); }
        }

        .pixel-button {
            transition: all 0.2s ease;
        }

        .pixel-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 102, 255, 0.4);
        }

        .pixel-button:active {
            transform: translateY(0);
        }

        /* Loading Animation */
        .loading-indicator {
            display: inline-block;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Auth Forms */
        .pixel-auth-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-darkest);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 25;
        }

        .pixel-auth-screen.hidden {
            display: none;
        }

        .pixel-form {
            max-width: 400px;
            width: 90%;
            padding: 24px;
            background: var(--bg-dark);
            border: 2px solid var(--border-light);
            border-top-color: var(--text-white);
            border-left-color: var(--text-white);
            border-right-color: var(--border-dark);
            border-bottom-color: var(--border-dark);
            margin-top: 16px;
        }

        .pixel-input-group {
            margin-bottom: 16px;
        }

        .pixel-label {
            display: block;
            font-size: 8px;
            color: var(--text-white);
            margin-bottom: 8px;
            font-weight: bold;
        }

        .pixel-input {
            width: 100%;
            padding: 12px;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            background: var(--bg-darkest);
            border: 2px solid var(--border-dark);
            border-top-color: var(--border-dark);
            border-left-color: var(--border-dark);
            border-right-color: var(--text-white);
            border-bottom-color: var(--text-white);
            color: var(--text-white);
            outline: none;
        }

        .pixel-input:focus {
            border-color: var(--pixel-blue);
            border-top-color: var(--pixel-blue);
            border-left-color: var(--pixel-blue);
            box-shadow: 0 0 8px rgba(0, 102, 255, 0.4);
        }

        .pixel-form-actions {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-top: 24px;
        }

        .pixel-button-secondary {
            background: var(--bg-darker);
            border-top-color: var(--border-light);
            border-left-color: var(--border-light);
        }

        .pixel-button-secondary:hover {
            background: var(--border-dark);
        }

        .auth-status {
            margin-top: 16px;
            padding: 8px 16px;
            background: var(--bg-dark);
            border: 1px solid var(--border-light);
            border-radius: 4px;
            font-size: 8px;
            color: var(--text-gray);
            text-align: center;
        }

        .auth-status.authenticated {
            color: var(--pixel-green);
            border-color: var(--pixel-green);
        }

        .auth-status.error {
            color: var(--pixel-red);
            border-color: var(--pixel-red);
        }

        /* Visual Notifications */
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 300px;
        }

        .notification {
            background: var(--bg-dark);
            border: 2px solid var(--border-light);
            border-top-color: var(--text-white);
            border-left-color: var(--text-white);
            border-right-color: var(--border-dark);
            border-bottom-color: var(--border-dark);
            padding: 12px 16px;
            margin-bottom: 8px;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            color: var(--text-white);
            animation: slideIn 0.3s ease-out;
            position: relative;
            overflow: hidden;
        }

        .notification.success {
            border-color: var(--pixel-green);
            background: linear-gradient(135deg, var(--bg-dark), rgba(0, 204, 68, 0.1));
        }

        .notification.error {
            border-color: var(--pixel-red);
            background: linear-gradient(135deg, var(--bg-dark), rgba(255, 0, 68, 0.1));
        }

        .notification.info {
            border-color: var(--pixel-blue);
            background: linear-gradient(135deg, var(--bg-dark), rgba(0, 102, 255, 0.1));
        }

        .notification.warning {
            border-color: var(--pixel-yellow);
            background: linear-gradient(135deg, var(--bg-dark), rgba(255, 204, 0, 0.1));
        }

        .notification.fadeOut {
            animation: fadeOut 0.3s ease-in forwards;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <!-- Welcome Screen -->
    <div id="welcome-screen" class="pixel-welcome-screen">
        <div class="pixel-box pixel-title-box">
            <h1 class="pixel-title">AWS QUEST</h1>
            <p class="pixel-subtitle">PIXEL ADVENTURE</p>
        </div>
        <div class="pixel-menu">
            <button class="pixel-button" id="start-adventure-btn">START GAME</button>
            <button class="pixel-button" id="show-levels-btn">SELECT LEVEL</button>
            <button class="pixel-button" id="show-components-btn">AWS COMPONENTS</button>
            <button class="pixel-button" id="show-login-btn">LOGIN</button>
            <button class="pixel-button" id="show-register-btn">REGISTER</button>
        </div>
        <div class="auth-status" id="auth-status">
            <span id="auth-message">Play as guest or login to save progress</span>
        </div>
    </div>

    <!-- Login Screen -->
    <div id="login-screen" class="pixel-auth-screen hidden">
        <div class="pixel-box pixel-title-box">
            <h2 class="pixel-title">LOGIN</h2>
        </div>
        <div class="pixel-form">
            <div class="pixel-input-group">
                <label class="pixel-label">USERNAME/EMAIL</label>
                <input type="text" class="pixel-input" id="login-username" placeholder="Enter username or email">
            </div>
            <div class="pixel-input-group">
                <label class="pixel-label">PASSWORD</label>
                <input type="password" class="pixel-input" id="login-password" placeholder="Enter password">
            </div>
            <div class="pixel-form-actions">
                <button class="pixel-button" id="login-submit-btn">LOGIN</button>
                <button class="pixel-button pixel-button-secondary" id="back-from-login-btn">BACK</button>
            </div>
        </div>
    </div>

    <!-- Register Screen -->
    <div id="register-screen" class="pixel-auth-screen hidden">
        <div class="pixel-box pixel-title-box">
            <h2 class="pixel-title">REGISTER</h2>
        </div>
        <div class="pixel-form">
            <div class="pixel-input-group">
                <label class="pixel-label">USERNAME</label>
                <input type="text" class="pixel-input" id="register-username" placeholder="Choose username">
            </div>
            <div class="pixel-input-group">
                <label class="pixel-label">EMAIL</label>
                <input type="email" class="pixel-input" id="register-email" placeholder="Enter email">
            </div>
            <div class="pixel-input-group">
                <label class="pixel-label">PASSWORD</label>
                <input type="password" class="pixel-input" id="register-password" placeholder="Choose password">
            </div>
            <div class="pixel-form-actions">
                <button class="pixel-button" id="register-submit-btn">REGISTER</button>
                <button class="pixel-button pixel-button-secondary" id="back-from-register-btn">BACK</button>
            </div>
        </div>
    </div>

    <!-- AWS Components Screen -->
    <div id="components-screen" class="pixel-screen hidden">
        <div class="pixel-box welcome-content">
            <h2 class="pixel-title">AWS COMPONENTS</h2>
            <p class="pixel-subtitle">Study by AWS Service Type</p>
            <div class="components-grid" id="components-grid"></div>
            <button class="pixel-button" id="back-from-components-btn">BACK TO MENU</button>
        </div>
    </div>

    <!-- Level Selection Screen -->
    <div id="level-selection-screen" class="pixel-level-screen">
        <div class="pixel-box pixel-title-box">
            <h2 class="pixel-title">SELECT LEVEL</h2>
        </div>
        <div class="level-grid" id="level-grid">
            <!-- Levels will be populated by JavaScript -->
        </div>
        <button class="pixel-button" id="back-to-menu-btn">BACK TO MENU</button>
    </div>

    <!-- Pixel Game Canvas -->
    <canvas id="game-canvas" width="800" height="600"></canvas>

    <!-- Visual Notifications -->
    <div id="notification-container" class="notification-container"></div>
    
    <!-- Progress Panel -->
    <div class="progress-panel" id="progress-panel">
        <div id="progress-content">
            <!-- Progress content will be populated by JavaScript -->
        </div>
    </div>
    
    <!-- Progress Button -->
    <button class="progress-button" onclick="showProgressPanel()">
        🏆 Progress
    </button>
    
    <!-- Challenge Panel -->
    <div class="challenge-panel" id="challenge-panel">
        <h2 style="color: var(--pixel-orange); margin-bottom: 20px; text-align: center; font-size: 12px;">Challenges & Mini-Games</h2>
        <div id="challenge-list">
            <!-- Challenge list will be populated by JavaScript -->
        </div>
        <div style="text-align: center; margin-top: 20px;">
            <button class="pixel-button" onclick="hideChallengeSelector()">
                Close
            </button>
        </div>
    </div>
    
    <!-- Challenge HUD -->
    <div class="challenge-hud" id="challenge-hud">
        <h4 id="challenge-name">Challenge Active</h4>
        <div class="challenge-progress" id="challenge-progress">0/10</div>
        <div class="challenge-timer" id="challenge-timer">60s</div>
    </div>
    
    <!-- Mini-Game Panel -->
    <div class="mini-game-panel" id="mini-game-panel">
        <div class="mini-game-header">
            <div class="mini-game-title" id="mini-game-title">Mini-Game</div>
            <button class="mini-game-close" onclick="hideMiniGameUI()">×</button>
        </div>
        <div class="mini-game-content" id="mini-game-content">
            <!-- Mini-game content will be populated by JavaScript -->
        </div>
    </div>
    
    <!-- Challenge Button -->
    <button class="challenge-button" onclick="showChallengeSelector()">
        ⚡ Challenges
    </button>
    
    <!-- Emergency Reset Button -->
    <button class="reset-button" onclick="forceReset()" title="Reset if stuck">
        🔄 Reset
    </button>
    
    <!-- Game Menu Bar -->
    <div class="game-menu-bar" id="game-menu-bar">
        <div class="menu-left">
            <button class="menu-button" onclick="saveGame()" title="Save Game">
                💾 Save
            </button>
            <button class="menu-button" onclick="returnToMainMenu()" title="Return to Main Menu">
                🏠 Menu
            </button>
            <button class="inventory-button" onclick="showInventoryUI()" title="Open Inventory">
                🎒 Inventory
            </button>
        </div>
        
        <div class="menu-center">
            <span class="game-title">AWS Quest</span>
        </div>
        
        <div class="menu-right">
            <button class="audio-toggle" id="audio-toggle" onclick="toggleAudio()" title="Toggle Audio">
                🔊 ON
            </button>
            <button class="music-toggle" id="music-toggle" onclick="toggleMusic()" title="Toggle Music">
                🎵 ON
            </button>
            <button class="sfx-toggle" id="sfx-toggle" onclick="toggleSFX()" title="Toggle Sound Effects">
                🔊 ON
            </button>
        </div>
    </div>

    <!-- Pixel UI Overlay -->
    <div class="ui-overlay">
        <!-- Pixel HUD -->
        <div class="pixel-hud" id="pixel-hud" style="display: none;">
            <div class="hud-left">
                <div class="pixel-character" id="pixel-character">🧙</div>
                <div class="pixel-stats">
                    <div class="pixel-stat-row">
                        <span class="pixel-stat-label">HP</span>
                        <div class="pixel-bar">
                            <div class="pixel-bar-fill hp" id="hp-bar" style="width: 100%"></div>
                        </div>
                        <span id="hp-text">100</span>
                    </div>
                    <div class="pixel-stat-row">
                        <span class="pixel-stat-label">MP</span>
                        <div class="pixel-bar">
                            <div class="pixel-bar-fill mp" id="mp-bar" style="width: 100%"></div>
                        </div>
                        <span id="mp-text">50</span>
                    </div>
                    <div class="pixel-stat-row">
                        <span class="pixel-stat-label">EXP</span>
                        <div class="pixel-bar">
                            <div class="pixel-bar-fill exp" id="exp-bar" style="width: 0%"></div>
                        </div>
                        <span id="exp-text">0</span>
                    </div>
                </div>
            </div>
            <div class="hud-right">
                <div class="pixel-level">LV <span id="character-level">1</span></div>
                <div class="pixel-score"><span id="character-score">0</span> PTS</div>
                <div class="pixel-progress">Q: <span id="level-progress">0/5</span></div>
            </div>
        </div>

        <!-- Pixel Battle Screen -->
        <div class="pixel-battle-screen" id="battle-screen">
            <div class="pixel-question" id="question-text">
                Welcome to AWS Quest! Select your first challenge.
            </div>
            <div class="pixel-options" id="battle-options">
                <button class="pixel-option" data-option="0">Option A</button>
                <button class="pixel-option" data-option="1">Option B</button>
                <button class="pixel-option" data-option="2">Option C</button>
                <button class="pixel-option" data-option="3">Option D</button>
            </div>
            <div class="pixel-battle-actions" style="margin-top: 16px; text-align: center;">
                <button class="pixel-button" id="attack-btn" disabled>ATTACK</button>
                <button class="pixel-button" id="next-battle-btn" style="display: none;">NEXT</button>
                <button class="pixel-button" id="menu-btn">MENU</button>
            </div>
        </div>

        <!-- Level Indicator -->
        <div class="pixel-level-indicator" id="level-indicator" style="display: none;">
            LEVEL: <span id="current-level-display">1</span> - <span id="current-level-name">AWS Basics</span>
        </div>

        <!-- Special Abilities Panel -->
        <div class="abilities-panel" id="abilities-panel">
            <div style="font-size: 8px; color: var(--pixel-yellow); margin-bottom: 8px;">SPECIAL ABILITIES</div>
            <button class="ability-button" id="fireball-btn" onclick="useAbility('fireball')">
                🔥 FIREBALL <span class="ability-cost">20 MP</span>
            </button>
            <button class="ability-button" id="heal-btn" onclick="useAbility('heal')">
                💚 HEAL <span class="ability-cost">15 MP</span>
            </button>
            <button class="ability-button" id="shield-btn" onclick="useAbility('shield')">
                🛡️ SHIELD <span class="ability-cost">25 MP</span>
            </button>
        </div>

        <!-- Combo Display -->
        <div class="combo-display" id="combo-display">
            COMBO: <span class="combo-number" id="combo-number">0</span>
        </div>

        <!-- Timer Display -->
        <div class="timer-display" id="timer-display">
            TIME: <span id="timer-value">30</span>s
        </div>

        <!-- Battle Type Indicator -->
        <div class="battle-type-indicator" id="battle-type-indicator">
            <span id="battle-type-text">NORMAL BATTLE</span>
        </div>
    </div>
        <!-- Game HUD -->
        <div class="game-hud">
            <div class="hud-left">
                <div class="character-avatar" id="character-avatar">🧙‍♂️</div>
                <div class="character-stats">
                    <div class="stat-bar">
                        <span class="stat-label">Health</span>
                        <div class="progress-bar">
                            <div class="progress-fill hp-fill" id="hp-bar" style="width: 100%"></div>
                        </div>
                        <span id="hp-text">100/100</span>
                    </div>
                    <div class="stat-bar">
                        <span class="stat-label">Mana</span>
                        <div class="progress-bar">
                            <div class="progress-fill mp-fill" id="mp-bar" style="width: 100%"></div>
                        </div>
                        <span id="mp-text">50/50</span>
                    </div>
                </div>
            </div>
            <div class="hud-right">
                <div class="level-display">Level <span id="character-level">1</span></div>
                <div class="score-display"><span id="character-score">0</span> XP</div>
            </div>
        </div>

        <!-- Character Stats Panel -->
        <div class="stats-panel" id="stats-panel">
            <div class="character-portrait">🧙‍♂️</div>
            <div class="character-name" id="character-name">Cloud Architect</div>
            <div class="stat-row">
                <span class="stat-name">Level</span>
                <span class="stat-value" id="stat-level">1</span>
            </div>
            <div class="stat-row">
                <span class="stat-name">Experience</span>
                <span class="stat-value" id="stat-exp">0 / 1000</span>
            </div>
            <div class="stat-row">
                <span class="stat-name">Battles Won</span>
                <span class="stat-value" id="stat-wins">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-name">Accuracy</span>
                <span class="stat-value" id="stat-accuracy">0%</span>
            </div>
            <div class="stat-row">
                <span class="stat-name">Win Streak</span>
                <span class="stat-value" id="stat-streak">0</span>
            </div>
        </div>

        <!-- Inventory Panel -->
        <div class="inventory-panel" id="inventory-panel">
            <div class="panel-title">🎒 Inventory</div>
            <div class="inventory-grid" id="inventory-grid">
                <!-- Inventory slots generated by JavaScript -->
            </div>
            <div style="text-align: center; color: var(--text-muted); font-size: 0.875rem;">
                Collect AWS artifacts and power-ups during battles!
            </div>
        </div>

        <!-- Battle Interface -->
        <div class="battle-interface" id="battle-interface">
            <div class="question-display">
                <div class="question-meta">
                    <span id="question-category">Loading...</span>
                    <div class="difficulty-badge" id="question-difficulty">Medium</div>
                </div>
                <div class="question-text" id="question-text">
                    Preparing your next cloud challenge...
                </div>
            </div>
            
            <div class="battle-options" id="battle-options">
                <!-- Options populated by JavaScript -->
            </div>
            
            <div class="battle-actions">
                <button class="rpg-button" id="attack-btn" disabled>⚔️ Attack</button>
                <button class="rpg-button btn-secondary" id="next-battle-btn" style="display: none;">➡️ Next Battle</button>
                <button class="rpg-button btn-secondary" id="inventory-btn" onclick="toggleInventory()">🎒 Inventory</button>
                <button class="rpg-button btn-secondary" id="stats-btn" onclick="toggleStats()">📊 Stats</button>
            </div>
        </div>
    </div>

    <script>
        // Enhanced Pixel Art Game State with Save System
        let gameState = {
            canvas: null,
            ctx: null,
            currentLevel: 1,
            currentStage: 'welcome', // welcome, battle, victory, defeat
            animationFrame: null,
            currentQuestion: null,
            selectedAnswer: null,
            
            // Authentication & Save System
            isAuthenticated: false,
            userToken: localStorage.getItem('userToken'),
            autoSaveInterval: null,
            lastSaveTime: null,
            saveInProgress: false,
            pendingSave: false,
            
            // Animation System
            animations: {
                particles: [],
                effects: [],
                transitions: [],
                screenShake: false,
                combos: [],
                damageNumbers: [],
                healingNumbers: []
            },
            
            // Enhanced Engagement System
            engagement: {
                streakMultiplier: 1,
                perfectAnswerBonus: 0,
                speedBonus: 0,
                difficulty: 'normal',
                powerUps: [],
                currentPowerUp: null,
                specialModes: [],
                dailyBonus: 1,
                weeklyChallenge: null,
                motivationalMessages: []
            },
            
            // Inventory System
            inventory: {
                items: [],
                capacity: 20,
                categories: ['consumables', 'equipment', 'materials', 'special'],
                equipped: {
                    weapon: null,
                    armor: null,
                    accessory: null
                },
                currency: {
                    coins: 0,
                    gems: 0,
                    awsCredits: 0
                }
            },
            player: {
                name: 'AWS Architect',
                level: 1,
                hp: 100,
                maxHp: 100,
                mp: 50,
                maxMp: 50,
                exp: 0,
                expToNext: 100,
                score: 0,
                wins: 0,
                streak: 0,
                accuracy: 0,
                totalQuestions: 0,
                correctAnswers: 0,
                x: 100,
                y: 200,
                sprite: 'mage',
                animationFrame: 0,
                direction: 'right',
                gamesPlayed: 0,
                levelsCompleted: [],
                achievements: [],
                achievementProgress: {},
                dailyStreak: 0,
                lastPlayDate: null,
                studyTime: 0,
                favoriteCategory: null,
                weakestCategory: null,
                longestStreak: 0,
                perfectRounds: 0,
                questionsInARow: 0,
                categoriesCompleted: [],
                badgesEarned: [],
                milestones: {},
                settings: {
                    sound: true,
                    music: true,
                    difficulty: 'normal',
                    autoSave: true
                }
            },
            enemy: {
                name: 'AWS Bug',
                hp: 50,
                maxHp: 50,
                x: 600,
                y: 200,
                sprite: 'monster',
                animationFrame: 0,
                isAlive: true
            },
            effects: [],
            background: 'forest',
            isInBattle: false,
            battleType: 'normal', // normal, boss, speed, endurance
            timeLimit: null,
            combo: 0,
            maxCombo: 0,
            specialAbilities: {
                fireball: { cooldown: 0, cost: 20, unlocked: true, level: 1 },
                heal: { cooldown: 0, cost: 15, unlocked: true, level: 1 },
                shield: { cooldown: 0, cost: 25, active: false, unlocked: false, level: 0 },
                lightning: { cooldown: 0, cost: 35, unlocked: false, level: 0 },
                blessing: { cooldown: 0, cost: 40, unlocked: false, level: 0 }
            },
            inventory: [],
            dailyChallenges: [],
            notifications: [],
            
            // Session tracking
            sessionStartTime: Date.now(),
            lastActivityTime: Date.now(),
            sessionStats: {
                questionsAnswered: 0,
                correctAnswers: 0,
                timeSpent: 0,
                levelsAttempted: [],
                achievementsEarned: [],
                unlockedFeatures: ['basic_gameplay'],
                progressStats: {
                    totalPlayTime: 0,
                    questionsAnswered: 0,
                    correctAnswers: 0,
                    categoriesPlayed: new Set(),
                    levelsCompleted: [],
                    averageResponseTime: 0,
                    bestStreak: 0,
                    perfectGames: 0,
                    studySessions: 0
                }
            },
            
            // Level progress tracking
            currentLevelProgress: {
                questionsAnswered: 0,
                questionsRequired: 5
            }
        };

        // Pixel Art Sprites (8x8 pixel characters using ASCII/Unicode)
        const SPRITES = {
            mage: {
                idle: ['🧙‍♂️', '🧙'],
                attack: ['⚡🧙‍♂️', '✨🧙'],
                hurt: ['😵🧙‍♂️', '💥🧙']
            },
            monster: {
                idle: ['👾', '🤖'],
                attack: ['💀👾', '🔥🤖'], 
                hurt: ['💥👾', '⚡🤖']
            },
            effects: {
                hit: ['💥', '⚡', '✨', '💫'],
                heal: ['💚', '🌟', '✨'],
                magic: ['🔮', '✨', '🌟', '💫']
            }
        };

        // Level Data
        const LEVELS = [
            // Easy Levels (1-3)
            {
                id: 1,
                name: 'AWS Basics',
                background: 'forest',
                playerEmoji: '🧙‍♂️',
                enemyEmoji: '🐛',
                questionDifficulty: 'easy',
                category: 'Compute',
                description: 'Learn the fundamentals of AWS services',
                requiredQuestions: 5
            },
            {
                id: 2,
                name: 'Storage Fundamentals',
                background: 'forest',
                playerEmoji: '🧙‍♂️',
                enemyEmoji: '📦',
                questionDifficulty: 'easy',
                category: 'Storage',
                description: 'Master S3, EBS, and storage basics',
                requiredQuestions: 5
            },
            {
                id: 3,
                name: 'Networking Basics',
                background: 'forest',
                playerEmoji: '🧙‍♂️',
                enemyEmoji: '🕷️',
                questionDifficulty: 'easy',
                category: 'Networking',
                description: 'Understand VPC and networking fundamentals',
                requiredQuestions: 5
            },
            
            // Medium Levels (4-7)
            {
                id: 4,
                name: 'EC2 Mastery',
                background: 'cave',
                playerEmoji: '🧙‍♂️',
                enemyEmoji: '🤖',
                questionDifficulty: 'medium',
                category: 'Compute',
                description: 'Advanced EC2, Auto Scaling, and Load Balancing',
                requiredQuestions: 8
            },
            {
                id: 5,
                name: 'Database Solutions',
                background: 'cave',
                playerEmoji: '🧙‍♂️',
                enemyEmoji: '🐲',
                questionDifficulty: 'medium',
                category: 'Database',
                description: 'Master RDS, DynamoDB, and database services',
                requiredQuestions: 8
            },
            {
                id: 6,
                name: 'Security & IAM',
                background: 'cave',
                playerEmoji: '🧙‍♂️',
                enemyEmoji: '🛡️',
                questionDifficulty: 'medium',
                category: 'Security',
                description: 'Advanced security, encryption, and access control',
                requiredQuestions: 8
            },
            {
                id: 7,
                name: 'Serverless Architecture',
                background: 'cave',
                playerEmoji: '🧙‍♂️',
                enemyEmoji: '👻',
                questionDifficulty: 'medium',
                category: 'Serverless',
                description: 'Lambda, API Gateway, and serverless patterns',
                requiredQuestions: 8
            },
            
            // Hard Levels (8-12)
            {
                id: 8,
                name: 'High Availability',
                background: 'castle',
                playerEmoji: '🧙‍♂️',
                enemyEmoji: '👹',
                questionDifficulty: 'hard',
                category: 'Disaster Recovery',
                description: 'Advanced resilience and disaster recovery',
                requiredQuestions: 10
            },
            {
                id: 9,
                name: 'Performance Optimization',
                background: 'castle',
                enemies: ['cache-demon', 'latency-dragon'],
                questionDifficulty: 'hard',
                category: 'Performance',
                description: 'Caching, CDN, and performance tuning',
                requiredQuestions: 10
            },
            {
                id: 10,
                name: 'Cost Optimization',
                background: 'castle',
                enemies: ['budget-beast', 'cost-optimizer'],
                questionDifficulty: 'hard',
                category: 'Cost Optimization',
                description: 'Advanced cost management and optimization',
                requiredQuestions: 10
            },
            {
                id: 11,
                name: 'Analytics & ML',
                background: 'castle',
                enemies: ['data-wizard', 'ml-overlord'],
                questionDifficulty: 'hard',
                category: 'Analytics',
                description: 'Big Data, Analytics, and Machine Learning',
                requiredQuestions: 10
            },
            {
                id: 12,
                name: 'Solutions Architect Master',
                background: 'castle',
                enemies: ['architect-emperor', 'final-boss'],
                questionDifficulty: 'hard',
                category: 'Mixed',
                description: 'Ultimate challenge covering all domains',
                requiredQuestions: 15
            }
        ];

        // Enhanced Achievement System
        const ACHIEVEMENTS = {
            // Learning Achievements
            'first_correct': {
                id: 'first_correct',
                name: 'First Success',
                description: 'Answer your first question correctly',
                icon: '🎯',
                type: 'learning',
                rarity: 'common',
                requirement: (stats) => stats.correctAnswers >= 1,
                reward: { exp: 50, title: 'Beginner' }
            },
            'streak_5': {
                id: 'streak_5',
                name: 'Getting the Hang of It',
                description: 'Get 5 questions correct in a row',
                icon: '🔥',
                type: 'streak',
                rarity: 'common',
                requirement: (stats) => stats.bestStreak >= 5,
                reward: { exp: 100, ability: 'focus_boost' }
            },
            'streak_10': {
                id: 'streak_10',
                name: 'On Fire',
                description: 'Get 10 questions correct in a row',
                icon: '🔥🔥',
                type: 'streak',
                rarity: 'uncommon',
                requirement: (stats) => stats.bestStreak >= 10,
                reward: { exp: 200, title: 'Streak Master' }
            },
            'streak_20': {
                id: 'streak_20',
                name: 'Unstoppable',
                description: 'Get 20 questions correct in a row',
                icon: '🔥🔥🔥',
                type: 'streak',
                rarity: 'rare',
                requirement: (stats) => stats.bestStreak >= 20,
                reward: { exp: 500, ability: 'time_dilation' }
            },
            'accuracy_80': {
                id: 'accuracy_80',
                name: 'Sharpshooter',
                description: 'Maintain 80% accuracy over 50 questions',
                icon: '🎯',
                type: 'accuracy',
                rarity: 'uncommon',
                requirement: (stats) => stats.questionsAnswered >= 50 && (stats.correctAnswers / stats.questionsAnswered) >= 0.8,
                reward: { exp: 300, title: 'Accurate' }
            },
            'accuracy_95': {
                id: 'accuracy_95',
                name: 'Perfectionist',
                description: 'Maintain 95% accuracy over 100 questions',
                icon: '💎',
                type: 'accuracy',
                rarity: 'legendary',
                requirement: (stats) => stats.questionsAnswered >= 100 && (stats.correctAnswers / stats.questionsAnswered) >= 0.95,
                reward: { exp: 1000, title: 'Master', ability: 'perfect_insight' }
            },
            'speed_demon': {
                id: 'speed_demon',
                name: 'Speed Demon',
                description: 'Answer 20 questions in under 5 seconds each',
                icon: '⚡',
                type: 'speed',
                rarity: 'rare',
                requirement: (stats) => stats.fastAnswers >= 20,
                reward: { exp: 400, ability: 'quick_thinking' }
            },
            'daily_grind': {
                id: 'daily_grind',
                name: 'Daily Grind',
                description: 'Study for 7 consecutive days',
                icon: '📅',
                type: 'consistency',
                rarity: 'uncommon',
                requirement: (stats) => stats.dailyStreak >= 7,
                reward: { exp: 500, title: 'Consistent' }
            },
            'marathon': {
                id: 'marathon',
                name: 'Marathon Runner',
                description: 'Study for 30 consecutive days',
                icon: '🏃‍♂️',
                type: 'consistency',
                rarity: 'legendary',
                requirement: (stats) => stats.dailyStreak >= 30,
                reward: { exp: 2000, title: 'Marathoner', ability: 'endurance' }
            },
            'category_master_compute': {
                id: 'category_master_compute',
                name: 'Compute Master',
                description: 'Answer 50 compute-related questions correctly',
                icon: '💻',
                type: 'category',
                rarity: 'uncommon',
                requirement: (stats) => stats.categoryCorrect?.compute >= 50,
                reward: { exp: 400, title: 'Compute Expert' }
            },
            'all_levels': {
                id: 'all_levels',
                name: 'Level Conqueror',
                description: 'Complete all available levels',
                icon: '👑',
                type: 'progression',
                rarity: 'legendary',
                requirement: (stats) => stats.levelsCompleted.length >= 12,
                reward: { exp: 3000, title: 'Conqueror', ability: 'master_insight' }
            },
            'perfect_level': {
                id: 'perfect_level',
                name: 'Flawless Victory',
                description: 'Complete a level with 100% accuracy',
                icon: '✨',
                type: 'performance',
                rarity: 'rare',
                requirement: (stats) => stats.perfectLevels >= 1,
                reward: { exp: 600, title: 'Flawless' }
            },
            'combo_master': {
                id: 'combo_master',
                name: 'Combo Master',
                description: 'Achieve a 15x combo multiplier',
                icon: '🎮',
                type: 'combo',
                rarity: 'rare',
                requirement: (stats) => stats.maxCombo >= 15,
                reward: { exp: 500, ability: 'combo_boost' }
            },
            'scholar': {
                id: 'scholar',
                name: 'Scholar',
                description: 'Answer 1000 questions correctly',
                icon: '📚',
                type: 'volume',
                rarity: 'epic',
                requirement: (stats) => stats.correctAnswers >= 1000,
                reward: { exp: 2000, title: 'Scholar' }
            },
            'aws_architect': {
                id: 'aws_architect',
                name: 'AWS Architect',
                description: 'Demonstrate mastery across all AWS domains',
                icon: '🏗️',
                type: 'mastery',
                rarity: 'legendary',
                requirement: (stats) => stats.domainMastery >= 5,
                reward: { exp: 5000, title: 'AWS Solutions Architect' }
            }
        };

        // Progress Tracking System
        const PROGRESS_MILESTONES = {
            questions: [10, 25, 50, 100, 250, 500, 1000, 2500, 5000],
            accuracy: [50, 60, 70, 80, 85, 90, 95, 98, 99],
            streak: [3, 5, 10, 15, 20, 25, 30, 50, 100],
            levels: [1, 3, 5, 8, 10, 12],
            study_time: [30, 60, 120, 300, 600, 1200, 2400, 4800] // minutes
        };
        
        // Special Challenges and Mini-Games System
        const SPECIAL_CHALLENGES = {
            'lightning_round': {
                id: 'lightning_round',
                name: 'Lightning Round',
                description: 'Answer 10 questions in 60 seconds',
                icon: '⚡',
                type: 'speed',
                timeLimit: 60,
                questionCount: 10,
                reward: { exp: 500, title: 'Lightning Fast' },
                requirements: { level: 3, accuracy: 70 }
            },
            'perfect_streak': {
                id: 'perfect_streak',
                name: 'Perfect Streak',
                description: 'Get 15 questions correct in a row',
                icon: '🎯',
                type: 'accuracy',
                streakRequired: 15,
                reward: { exp: 750, ability: 'precision_mode' },
                requirements: { level: 5, streak: 10 }
            },
            'category_master': {
                id: 'category_master',
                name: 'Category Master',
                description: 'Answer 20 questions from a specific category',
                icon: '🎓',
                type: 'specialization',
                questionCount: 20,
                reward: { exp: 600, title: 'Category Expert' },
                requirements: { level: 2 }
            },
            'endurance_test': {
                id: 'endurance_test',
                name: 'Endurance Test',
                description: 'Survive 50 questions without losing more than 25% health',
                icon: '💪',
                type: 'endurance',
                questionCount: 50,
                maxHpLoss: 0.25,
                reward: { exp: 1000, ability: 'iron_will' },
                requirements: { level: 7, hp: 100 }
            },
            'memory_game': {
                id: 'memory_game',
                name: 'Memory Challenge',
                description: 'Remember the pattern of AWS service icons',
                icon: '🧠',
                type: 'memory',
                patterns: 5,
                reward: { exp: 400, ability: 'enhanced_memory' },
                requirements: { level: 4 }
            },
            'boss_rush': {
                id: 'boss_rush',
                name: 'Boss Rush',
                description: 'Defeat 3 bosses in a row',
                icon: '👹',
                type: 'boss',
                bossCount: 3,
                reward: { exp: 1500, title: 'Boss Slayer' },
                requirements: { level: 8, wins: 50 }
            },
            'time_trial': {
                id: 'time_trial',
                name: 'Time Trial',
                description: 'Complete a level in under 5 minutes',
                icon: '⏱️',
                type: 'time',
                timeLimit: 300, // 5 minutes
                reward: { exp: 350, ability: 'time_master' },
                requirements: { level: 3 }
            },
            'trivia_master': {
                id: 'trivia_master',
                name: 'Trivia Master',
                description: 'Answer questions from all AWS domains',
                icon: '🏆',
                type: 'comprehensive',
                domainsRequired: ['compute', 'storage', 'database', 'networking', 'security'],
                reward: { exp: 2000, title: 'AWS Trivia Master' },
                requirements: { level: 10, accuracy: 80 }
            }
        };
        
        // Mini-Games Definitions
        const MINI_GAMES = {
            'service_matcher': {
                id: 'service_matcher',
                name: 'Service Matcher',
                description: 'Match AWS services to their descriptions',
                icon: '🔗',
                type: 'matching',
                timeLimit: 45,
                pairs: 6,
                reward: { exp: 200, coins: 50 }
            },
            'architecture_builder': {
                id: 'architecture_builder',
                name: 'Architecture Builder',
                description: 'Build a complete AWS architecture',
                icon: '🏗️',
                type: 'construction',
                timeLimit: 90,
                components: 8,
                reward: { exp: 400, coins: 100 }
            },
            'cost_calculator': {
                id: 'cost_calculator',
                name: 'Cost Calculator',
                description: 'Estimate the cost of AWS services',
                icon: '💰',
                type: 'calculation',
                timeLimit: 60,
                scenarios: 3,
                reward: { exp: 300, coins: 75 }
            },
            'security_audit': {
                id: 'security_audit',
                name: 'Security Audit',
                description: 'Find security vulnerabilities in configurations',
                icon: '🔍',
                type: 'analysis',
                timeLimit: 120,
                issues: 5,
                reward: { exp: 500, coins: 125 }
            },
            'snake_game': {
                id: 'snake_game',
                name: 'AWS Snake',
                description: 'Classic Snake game with AWS services',
                icon: '🐍',
                type: 'arcade',
                timeLimit: 180,
                targetScore: 100,
                reward: { exp: 250, coins: 60 }
            },
            'memory_cards': {
                id: 'memory_cards',
                name: 'Memory Cards',
                description: 'Match pairs of AWS service cards',
                icon: '🎴',
                type: 'memory',
                timeLimit: 90,
                pairs: 8,
                reward: { exp: 300, coins: 70 }
            }
        };

        // Challenge and Mini-Game State
        const challengeState = {
            isActive: false,
            currentChallenge: null,
            startTime: null,
            progress: 0,
            requirements: {},
            rewards: {},
            miniGameActive: false,
            miniGameData: {},
            availableChallenges: [],
            completedChallenges: [],
            dailyChallenges: [],
            specialEvents: []
        };
        
        // Audio System State
        const audioState = {
            enabled: true,
            musicEnabled: true,
            sfxEnabled: true,
            masterVolume: 0.7,
            musicVolume: 0.5,
            sfxVolume: 0.8,
            currentTrack: null,
            audioContext: null,
            sounds: {},
            musicTracks: {},
            isPlaying: false,
            fadeInterval: null
        };
        
        // Audio System Implementation
        function initializeAudioSystem() {
            console.log('🎵 Initializing Audio System...');
            
            // Create audio context
            try {
                audioState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Load sound effects
                loadSoundEffects();
                
                // Load music tracks
                loadMusicTracks();
                
                // Set up audio controls
                setupAudioControls();
                
                console.log('✅ Audio system initialized');
            } catch (error) {
                console.warn('⚠️ Audio system not available:', error);
                audioState.enabled = false;
            }
        }
        
        function loadSoundEffects() {
            const soundEffects = {
                'correct': createOscillatorSound(800, 0.3, 'sine'),
                'incorrect': createOscillatorSound(200, 0.5, 'sawtooth'),
                'click': createOscillatorSound(400, 0.1, 'square'),
                'levelup': createOscillatorSound(600, 0.8, 'sine'),
                'achievement': createOscillatorSound(1000, 1.0, 'sine'),
                'attack': createOscillatorSound(300, 0.4, 'sawtooth'),
                'heal': createOscillatorSound(500, 0.6, 'sine'),
                'shield': createOscillatorSound(700, 0.5, 'triangle'),
                'damage': createOscillatorSound(150, 0.3, 'sawtooth'),
                'victory': createOscillatorSound(900, 1.2, 'sine'),
                'defeat': createOscillatorSound(100, 1.5, 'sawtooth'),
                'notification': createOscillatorSound(450, 0.4, 'triangle'),
                'combo': createOscillatorSound(650, 0.3, 'sine'),
                'perfect': createOscillatorSound(1200, 0.8, 'sine')
            };
            
            audioState.sounds = soundEffects;
        }
        
        function createOscillatorSound(frequency, duration, type = 'sine') {
            return {
                frequency: frequency,
                duration: duration,
                type: type,
                play: function() {
                    if (!audioState.enabled || !audioState.sfxEnabled) return;
                    
                    try {
                        const oscillator = audioState.audioContext.createOscillator();
                        const gainNode = audioState.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioState.audioContext.destination);
                        
                        oscillator.frequency.value = this.frequency;
                        oscillator.type = this.type;
                        
                        const volume = audioState.masterVolume * audioState.sfxVolume;
                        gainNode.gain.setValueAtTime(volume, audioState.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioState.audioContext.currentTime + this.duration);
                        
                        oscillator.start(audioState.audioContext.currentTime);
                        oscillator.stop(audioState.audioContext.currentTime + this.duration);
                    } catch (error) {
                        console.warn('Error playing sound:', error);
                    }
                }
            };
        }
        
        function loadMusicTracks() {
            // Create upbeat adventure music tracks using Web Audio API
            const musicTracks = {
                'menu': createAdventurousTrack([440, 554, 659], 'upbeat'),
                'battle': createAdventurousTrack([523, 659, 784], 'energetic'),
                'victory': createAdventurousTrack([659, 784, 988], 'triumphant'),
                'boss': createAdventurousTrack([392, 523, 659], 'epic')
            };
            
            audioState.musicTracks = musicTracks;
        }
        
        function createAdventurousTrack(frequencies, mood) {
            return {
                frequencies: frequencies,
                mood: mood,
                oscillators: [],
                gainNodes: [],
                isPlaying: false,
                
                play: function() {
                    if (!audioState.enabled || !audioState.musicEnabled || this.isPlaying) return;
                    
                    this.isPlaying = true;
                    
                    this.frequencies.forEach((freq, index) => {
                        const oscillator = audioState.audioContext.createOscillator();
                        const gainNode = audioState.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioState.audioContext.destination);
                        
                        oscillator.frequency.value = freq;
                        oscillator.type = index % 2 === 0 ? 'triangle' : 'sine';
                        
                        const volume = (audioState.masterVolume * audioState.musicVolume) / this.frequencies.length;
                        gainNode.gain.setValueAtTime(volume, audioState.audioContext.currentTime);
                        
                        // Add rhythmic pulsing for adventure feel
                        const pulseDuration = this.mood === 'upbeat' ? 800 : 
                                            this.mood === 'energetic' ? 600 : 
                                            this.mood === 'triumphant' ? 1000 : 700;
                        
                        setInterval(() => {
                            if (this.isPlaying) {
                                // Create rhythmic volume changes
                                const targetVolume = volume * (0.7 + Math.random() * 0.3);
                                gainNode.gain.setValueAtTime(targetVolume, audioState.audioContext.currentTime);
                                gainNode.gain.exponentialRampToValueAtTime(volume, audioState.audioContext.currentTime + 0.1);
                                
                                // Add melodic variation
                                const variation = (Math.random() - 0.5) * 50;
                                oscillator.frequency.value = freq + variation;
                            }
                        }, pulseDuration + index * 200);
                        
                        oscillator.start(audioState.audioContext.currentTime);
                        
                        this.oscillators.push(oscillator);
                        this.gainNodes.push(gainNode);
                    });
                },
                
                stop: function() {
                    if (!this.isPlaying) return;
                    
                    this.isPlaying = false;
                    
                    this.oscillators.forEach(osc => {
                        try {
                            osc.stop(audioState.audioContext.currentTime);
                        } catch (e) {
                            console.warn('Error stopping oscillator:', e);
                        }
                    });
                    
                    this.oscillators = [];
                    this.gainNodes = [];
                }
            };
        }
        
        function createAmbientTrack(frequencies, mood) {
            return {
                frequencies: frequencies,
                mood: mood,
                oscillators: [],
                gainNodes: [],
                isPlaying: false,
                
                play: function() {
                    if (!audioState.enabled || !audioState.musicEnabled || this.isPlaying) return;
                    
                    this.isPlaying = true;
                    
                    this.frequencies.forEach((freq, index) => {
                        const oscillator = audioState.audioContext.createOscillator();
                        const gainNode = audioState.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioState.audioContext.destination);
                        
                        oscillator.frequency.value = freq;
                        oscillator.type = 'sine';
                        
                        const volume = (audioState.masterVolume * audioState.musicVolume) / this.frequencies.length;
                        gainNode.gain.setValueAtTime(volume, audioState.audioContext.currentTime);
                        
                        // Add subtle frequency modulation
                        setInterval(() => {
                            if (this.isPlaying) {
                                const variation = (Math.random() - 0.5) * 20;
                                oscillator.frequency.value = freq + variation;
                            }
                        }, 2000 + index * 500);
                        
                        oscillator.start(audioState.audioContext.currentTime);
                        
                        this.oscillators.push(oscillator);
                        this.gainNodes.push(gainNode);
                    });
                },
                
                stop: function() {
                    if (!this.isPlaying) return;
                    
                    this.isPlaying = false;
                    
                    this.oscillators.forEach(osc => {
                        try {
                            osc.stop();
                        } catch (e) {}
                    });
                    
                    this.oscillators = [];
                    this.gainNodes = [];
                },
                
                fadeOut: function(duration = 1000) {
                    if (!this.isPlaying) return;
                    
                    const fadeSteps = 20;
                    const fadeInterval = duration / fadeSteps;
                    let step = 0;
                    
                    const fade = setInterval(() => {
                        step++;
                        const volume = (audioState.masterVolume * audioState.musicVolume * (fadeSteps - step)) / (fadeSteps * this.frequencies.length);
                        
                        this.gainNodes.forEach(gainNode => {
                            if (gainNode) {
                                gainNode.gain.setValueAtTime(Math.max(0, volume), audioState.audioContext.currentTime);
                            }
                        });
                        
                        if (step >= fadeSteps) {
                            clearInterval(fade);
                            this.stop();
                        }
                    }, fadeInterval);
                }
            };
        }
        
        function playSound(soundName) {
            if (!audioState.enabled || !audioState.sfxEnabled) return;
            
            const sound = audioState.sounds[soundName];
            if (sound) {
                sound.play();
            }
        }
        
        function playMusic(trackName) {
            if (!audioState.enabled || !audioState.musicEnabled) return;
            
            // Stop current track
            if (audioState.currentTrack) {
                audioState.currentTrack.fadeOut(500);
            }
            
            // Start new track
            const track = audioState.musicTracks[trackName];
            if (track) {
                setTimeout(() => {
                    track.play();
                    audioState.currentTrack = track;
                }, 500);
            }
        }
        
        function stopMusic() {
            if (audioState.currentTrack) {
                audioState.currentTrack.fadeOut(1000);
                audioState.currentTrack = null;
            }
        }
        
        function setupAudioControls() {
            // Load audio settings from localStorage
            const savedAudioSettings = localStorage.getItem('audioSettings');
            if (savedAudioSettings) {
                const settings = JSON.parse(savedAudioSettings);
                audioState.enabled = settings.enabled !== false;
                audioState.musicEnabled = settings.musicEnabled !== false;
                audioState.sfxEnabled = settings.sfxEnabled !== false;
                audioState.masterVolume = settings.masterVolume || 0.7;
                audioState.musicVolume = settings.musicVolume || 0.5;
                audioState.sfxVolume = settings.sfxVolume || 0.8;
            }
        }
        
        function saveAudioSettings() {
            const settings = {
                enabled: audioState.enabled,
                musicEnabled: audioState.musicEnabled,
                sfxEnabled: audioState.sfxEnabled,
                masterVolume: audioState.masterVolume,
                musicVolume: audioState.musicVolume,
                sfxVolume: audioState.sfxVolume
            };
            
            localStorage.setItem('audioSettings', JSON.stringify(settings));
        }
        
        function toggleAudio() {
            audioState.enabled = !audioState.enabled;
            
            if (!audioState.enabled) {
                stopMusic();
            } else {
                playMusic('menu');
            }
            
            saveAudioSettings();
            updateAudioUI();
        }
        
        function toggleMusic() {
            audioState.musicEnabled = !audioState.musicEnabled;
            
            if (!audioState.musicEnabled) {
                stopMusic();
            } else if (audioState.enabled) {
                playMusic('menu');
            }
            
            saveAudioSettings();
            updateAudioUI();
        }
        
        function toggleSFX() {
            audioState.sfxEnabled = !audioState.sfxEnabled;
            
            if (audioState.sfxEnabled) {
                playSound('click');
            }
            
            saveAudioSettings();
            updateAudioUI();
        }
        
        function updateAudioUI() {
            const audioToggle = document.getElementById('audio-toggle');
            const musicToggle = document.getElementById('music-toggle');
            const sfxToggle = document.getElementById('sfx-toggle');
            
            if (audioToggle) {
                audioToggle.textContent = audioState.enabled ? '🔊 ON' : '🔇 OFF';
                audioToggle.style.color = audioState.enabled ? 'var(--pixel-green)' : 'var(--pixel-red)';
            }
            
            if (musicToggle) {
                musicToggle.textContent = audioState.musicEnabled ? '🎵 ON' : '🎵 OFF';
                musicToggle.style.color = audioState.musicEnabled ? 'var(--pixel-green)' : 'var(--pixel-red)';
            }
            
            if (sfxToggle) {
                sfxToggle.textContent = audioState.sfxEnabled ? '🔊 ON' : '🔊 OFF';
                sfxToggle.style.color = audioState.sfxEnabled ? 'var(--pixel-green)' : 'var(--pixel-red)';
            }
        }
        
        // Advanced Animation System
        function initializeAnimationSystem() {
            console.log('✨ Initializing Animation System...');
            
            // Clear existing animations
            gameState.animations.particles = [];
            gameState.animations.effects = [];
            gameState.animations.transitions = [];
            gameState.animations.combos = [];
            gameState.animations.damageNumbers = [];
            gameState.animations.healingNumbers = [];
            
            console.log('✅ Animation system initialized');
        }
        
        // Particle System
        function createParticle(x, y, type, options = {}) {
            const particle = {
                id: Date.now() + Math.random(),
                x: x,
                y: y,
                type: type,
                startTime: Date.now(),
                duration: options.duration || 2000,
                color: options.color || 'var(--pixel-cyan)',
                size: options.size || 4,
                velocity: {
                    x: options.velocityX || (Math.random() - 0.5) * 2,
                    y: options.velocityY || -Math.random() * 2
                },
                gravity: options.gravity || 0.1,
                opacity: options.opacity || 1,
                text: options.text || '✨',
                completed: false
            };
            
            gameState.animations.particles.push(particle);
            return particle;
        }
        
        function updateParticles() {
            gameState.animations.particles = gameState.animations.particles.filter(particle => {
                const elapsed = Date.now() - particle.startTime;
                const progress = elapsed / particle.duration;
                
                if (progress >= 1) {
                    return false; // Remove completed particles
                }
                
                // Update position
                particle.x += particle.velocity.x;
                particle.y += particle.velocity.y;
                particle.velocity.y += particle.gravity;
                
                // Update opacity
                particle.opacity = 1 - progress;
                
                return true;
            });
        }
        
        function renderParticles() {
            if (!gameState.ctx) return;
            
            gameState.animations.particles.forEach(particle => {
                gameState.ctx.save();
                gameState.ctx.globalAlpha = particle.opacity;
                gameState.ctx.fillStyle = particle.color;
                gameState.ctx.font = `${particle.size}px "Press Start 2P"`;
                gameState.ctx.textAlign = 'center';
                gameState.ctx.fillText(particle.text, particle.x, particle.y);
                gameState.ctx.restore();
            });
        }
        
        // Battle Effects
        function createBattleEffect(type, text, x, y, color) {
            const effect = {
                id: Date.now() + Math.random(),
                type: type,
                text: text,
                x: x,
                y: y,
                color: color,
                startTime: Date.now(),
                duration: type === 'damage' ? 1200 : 1000,
                completed: false
            };
            
            gameState.animations.effects.push(effect);
            
            // Create DOM element for animation
            const element = document.createElement('div');
            element.className = `battle-effect ${type}`;
            element.textContent = text;
            element.style.left = `${x}px`;
            element.style.top = `${y}px`;
            element.style.color = color;
            
            document.body.appendChild(element);
            
            // Remove element after animation
            setTimeout(() => {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            }, effect.duration);
            
            return effect;
        }
        
        function showDamageNumber(damage, x, y) {
            createBattleEffect('damage', `-${damage}`, x, y, 'var(--pixel-red)');
            createParticle(x, y, 'damage', {
                text: '💥',
                color: 'var(--pixel-red)',
                duration: 800,
                velocityY: -1
            });
        }
        
        function showHealingNumber(healing, x, y) {
            createBattleEffect('heal', `+${healing}`, x, y, 'var(--pixel-green)');
            createParticle(x, y, 'heal', {
                text: '💚',
                color: 'var(--pixel-green)',
                duration: 800,
                velocityY: -1
            });
        }
        
        function showComboEffect(combo, x, y) {
            createBattleEffect('combo', `${combo}x COMBO!`, x, y, 'var(--pixel-orange)');
            
            // Create sparkle particles
            for (let i = 0; i < 5; i++) {
                createParticle(x + (Math.random() - 0.5) * 50, y + (Math.random() - 0.5) * 30, 'sparkle', {
                    text: '✨',
                    color: 'var(--pixel-yellow)',
                    duration: 1000 + Math.random() * 500,
                    velocityX: (Math.random() - 0.5) * 3,
                    velocityY: -Math.random() * 3
                });
            }
        }
        
        // Screen Effects
        function triggerScreenShake(duration = 300) {
            gameState.animations.screenShake = true;
            document.body.classList.add('animate-screen-shake');
            
            setTimeout(() => {
                gameState.animations.screenShake = false;
                document.body.classList.remove('animate-screen-shake');
            }, duration);
        }
        
        function showScreenTransition(text, duration = 2000) {
            const transition = document.createElement('div');
            transition.className = 'screen-transition active';
            transition.innerHTML = `<div class="screen-transition-text">${text}</div>`;
            
            document.body.appendChild(transition);
            
            setTimeout(() => {
                transition.classList.remove('active');
                setTimeout(() => {
                    if (transition.parentNode) {
                        transition.parentNode.removeChild(transition);
                    }
                }, 500);
            }, duration);
        }
        
        // Enhanced Button Animations
        function animateButton(button, type = 'clicked') {
            if (!button) return;
            
            button.classList.add(`animate-${type}`);
            
            setTimeout(() => {
                button.classList.remove(`animate-${type}`);
            }, type === 'clicked' ? 300 : 500);
        }
        
        // Level Up Animation
        function showLevelUpAnimation(newLevel) {
            const levelUpDiv = document.createElement('div');
            levelUpDiv.className = 'battle-effect level-up';
            levelUpDiv.textContent = `LEVEL UP! ${newLevel}`;
            levelUpDiv.style.left = '50%';
            levelUpDiv.style.top = '40%';
            levelUpDiv.style.transform = 'translate(-50%, -50%)';
            levelUpDiv.style.fontSize = '20px';
            levelUpDiv.style.color = 'var(--pixel-yellow)';
            
            document.body.appendChild(levelUpDiv);
            
            // Create celebration particles
            for (let i = 0; i < 20; i++) {
                createParticle(
                    window.innerWidth / 2 + (Math.random() - 0.5) * 100,
                    window.innerHeight / 2 + (Math.random() - 0.5) * 100,
                    'celebration',
                    {
                        text: ['🎉', '✨', '🌟', '💫'][Math.floor(Math.random() * 4)],
                        color: ['var(--pixel-yellow)', 'var(--pixel-orange)', 'var(--pixel-cyan)', 'var(--pixel-green)'][Math.floor(Math.random() * 4)],
                        duration: 2000 + Math.random() * 1000,
                        velocityX: (Math.random() - 0.5) * 4,
                        velocityY: -Math.random() * 4
                    }
                );
            }
            
            setTimeout(() => {
                if (levelUpDiv.parentNode) {
                    levelUpDiv.parentNode.removeChild(levelUpDiv);
                }
            }, 1500);
        }
        
        // Achievement Animation
        function showAchievementAnimation(achievement) {
            // Create sparkle effect
            for (let i = 0; i < 15; i++) {
                createParticle(
                    window.innerWidth - 200 + (Math.random() - 0.5) * 100,
                    100 + (Math.random() - 0.5) * 50,
                    'achievement',
                    {
                        text: ['🏆', '⭐', '🎖️', '👑'][Math.floor(Math.random() * 4)],
                        color: achievement.rarity === 'legendary' ? 'var(--pixel-orange)' : 
                               achievement.rarity === 'epic' ? 'var(--pixel-purple)' : 
                               achievement.rarity === 'rare' ? 'var(--pixel-blue)' : 'var(--pixel-green)',
                        duration: 3000 + Math.random() * 1000,
                        velocityX: (Math.random() - 0.5) * 2,
                        velocityY: -Math.random() * 2
                    }
                );
            }
        }
        
        // Answer Animation
        function animateAnswerSelection(button, isCorrect) {
            if (!button) return;
            
            // Remove any existing animation classes
            button.classList.remove('animate-correct-answer', 'animate-wrong-answer');
            
            // Add appropriate animation
            if (isCorrect) {
                button.classList.add('animate-correct-answer');
                
                // Create success particles
                const rect = button.getBoundingClientRect();
                for (let i = 0; i < 8; i++) {
                    createParticle(
                        rect.left + rect.width / 2 + (Math.random() - 0.5) * rect.width,
                        rect.top + rect.height / 2 + (Math.random() - 0.5) * rect.height,
                        'success',
                        {
                            text: '✓',
                            color: 'var(--pixel-green)',
                            duration: 1000,
                            velocityX: (Math.random() - 0.5) * 2,
                            velocityY: -Math.random() * 2
                        }
                    );
                }
            } else {
                button.classList.add('animate-wrong-answer');
                triggerScreenShake(200);
                
                // Create error particles
                const rect = button.getBoundingClientRect();
                for (let i = 0; i < 5; i++) {
                    createParticle(
                        rect.left + rect.width / 2 + (Math.random() - 0.5) * rect.width,
                        rect.top + rect.height / 2 + (Math.random() - 0.5) * rect.height,
                        'error',
                        {
                            text: '✗',
                            color: 'var(--pixel-red)',
                            duration: 800,
                            velocityX: (Math.random() - 0.5) * 3,
                            velocityY: -Math.random() * 2
                        }
                    );
                }
            }
        }
        
        // UI Animation Enhancements
        function applyUIAnimations() {
            // Add floating animations to key UI elements
            const floatingElements = [
                'welcome-title',
                'hud-score',
                'hud-level',
                'hud-hp',
                'hud-mp'
            ];
            
            floatingElements.forEach((id, index) => {
                const element = document.getElementById(id);
                if (element) {
                    element.classList.add('floating-element');
                    if (index % 2 === 0) {
                        element.classList.add('slow');
                    } else {
                        element.classList.add('fast');
                    }
                }
            });
            
            // Add breathing animation to icons
            const breathingIcons = document.querySelectorAll('.hud-icon, .achievement-icon');
            breathingIcons.forEach(icon => {
                icon.classList.add('breathing-icon');
            });
            
            // Add glow effect to important buttons
            const glowButtons = document.querySelectorAll('#start-adventure-btn, #attack-btn');
            glowButtons.forEach(button => {
                button.classList.add('glow-effect');
            });
            
            // Add staggered animations to options
            const options = document.querySelectorAll('.pixel-option');
            options.forEach((option, index) => {
                option.classList.add('staggered-item');
                option.style.animationDelay = `${index * 0.1}s`;
            });
            
            // Add progress bar animations
            const progressBars = document.querySelectorAll('.progress-fill');
            progressBars.forEach(bar => {
                bar.classList.add('progress-bar');
            });
        }
        
        // Enhanced Screen Transitions
        function showCustomTransition(type, message, duration = 2000) {
            const transitions = {
                'victory': {
                    message: `🎉 ${message}`,
                    color: 'var(--pixel-green)',
                    particles: ['🎊', '🎉', '✨', '⭐']
                },
                'defeat': {
                    message: `💀 ${message}`,
                    color: 'var(--pixel-red)',
                    particles: ['💥', '💀', '⚡', '🔥']
                },
                'levelup': {
                    message: `📈 ${message}`,
                    color: 'var(--pixel-yellow)',
                    particles: ['🌟', '💫', '✨', '🎯']
                },
                'achievement': {
                    message: `🏆 ${message}`,
                    color: 'var(--pixel-orange)',
                    particles: ['🏆', '🎖️', '👑', '⭐']
                }
            };
            
            const config = transitions[type] || {
                message: message,
                color: 'var(--pixel-cyan)',
                particles: ['✨', '💫', '🌟', '⭐']
            };
            
            const transition = document.createElement('div');
            transition.className = 'screen-transition active';
            transition.innerHTML = `
                <div class="screen-transition-text" style="color: ${config.color}">
                    ${config.message}
                </div>
            `;
            
            document.body.appendChild(transition);
            
            // Create themed particles
            for (let i = 0; i < 20; i++) {
                createParticle(
                    Math.random() * window.innerWidth,
                    Math.random() * window.innerHeight,
                    type,
                    {
                        text: config.particles[Math.floor(Math.random() * config.particles.length)],
                        color: config.color,
                        duration: duration,
                        velocityX: (Math.random() - 0.5) * 3,
                        velocityY: -Math.random() * 3
                    }
                );
            }
            
            setTimeout(() => {
                transition.classList.remove('active');
                setTimeout(() => {
                    if (transition.parentNode) {
                        transition.parentNode.removeChild(transition);
                    }
                }, 500);
            }, duration);
        }
        
        // Enhanced Engagement System
        function initializeEngagementSystem() {
            console.log('🎯 Initializing Engagement System...');
            
            // Load motivational messages
            gameState.engagement.motivationalMessages = [
                "You're becoming an AWS expert! 🚀",
                "Your cloud skills are leveling up! ☁️",
                "Architecture mastery incoming! 🏗️",
                "Keep building those cloud solutions! 💪",
                "Your AWS journey is inspiring! ⭐",
                "Cloud architect level: Rising! 📈",
                "Solution design skills: Impressive! 🎯",
                "AWS certification: Getting closer! 🏆"
            ];
            
            // Initialize power-ups
            gameState.engagement.powerUps = [
                { id: 'double_score', name: 'Double Score', duration: 30000, icon: '⚡' },
                { id: 'time_slow', name: 'Time Slow', duration: 20000, icon: '⏰' },
                { id: 'shield', name: 'Shield', duration: 45000, icon: '🛡️' },
                { id: 'combo_boost', name: 'Combo Boost', duration: 25000, icon: '🔥' },
                { id: 'perfect_streak', name: 'Perfect Streak', duration: 15000, icon: '✨' }
            ];
            
            console.log('✅ Engagement system initialized');
        }
        
        function calculateEngagementScore(isCorrect, responseTime) {
            let baseScore = isCorrect ? 100 : 0;
            
            // Streak multiplier
            if (gameState.player.streak > 0) {
                gameState.engagement.streakMultiplier = 1 + (gameState.player.streak * 0.1);
                baseScore *= gameState.engagement.streakMultiplier;
            }
            
            // Speed bonus (faster answers get more points)
            if (isCorrect && responseTime < 10000) {
                gameState.engagement.speedBonus = Math.max(0, 50 - (responseTime / 200));
                baseScore += gameState.engagement.speedBonus;
            }
            
            // Perfect answer bonus (first try, fast response)
            if (isCorrect && responseTime < 5000 && gameState.player.streak > 0) {
                gameState.engagement.perfectAnswerBonus = 75;
                baseScore += gameState.engagement.perfectAnswerBonus;
            }
            
            // Power-up bonuses
            if (gameState.engagement.currentPowerUp) {
                switch (gameState.engagement.currentPowerUp.id) {
                    case 'double_score':
                        baseScore *= 2;
                        break;
                    case 'combo_boost':
                        baseScore += gameState.combo * 25;
                        break;
                    case 'perfect_streak':
                        if (isCorrect) baseScore += 100;
                        break;
                }
            }
            
            // Daily bonus
            const today = new Date().toDateString();
            const lastPlayed = localStorage.getItem('lastPlayedDate');
            if (lastPlayed !== today) {
                gameState.engagement.dailyBonus = 1.5;
                localStorage.setItem('lastPlayedDate', today);
                addNotification('Daily bonus active! +50% XP', 'success');
            }
            
            baseScore *= gameState.engagement.dailyBonus;
            
            return Math.floor(baseScore);
        }
        
        function showMotivationalMessage() {
            const messages = gameState.engagement.motivationalMessages;
            const randomMessage = messages[Math.floor(Math.random() * messages.length)];
            
            setTimeout(() => {
                addNotification(randomMessage, 'info');
            }, 1000);
        }
        
        function triggerPowerUp(powerUpId) {
            const powerUp = gameState.engagement.powerUps.find(p => p.id === powerUpId);
            if (!powerUp) return;
            
            gameState.engagement.currentPowerUp = powerUp;
            
            // Show power-up notification
            addNotification(`${powerUp.icon} ${powerUp.name} activated!`, 'success');
            
            // Power-up specific effects
            switch (powerUpId) {
                case 'shield':
                    gameState.specialAbilities.shield.active = true;
                    gameState.specialAbilities.shield.duration = powerUp.duration;
                    break;
                case 'time_slow':
                    // Visual effect for time slow
                    document.body.style.filter = 'hue-rotate(240deg)';
                    break;
            }
            
            // Remove power-up after duration
            setTimeout(() => {
                gameState.engagement.currentPowerUp = null;
                
                // Reset effects
                switch (powerUpId) {
                    case 'shield':
                        gameState.specialAbilities.shield.active = false;
                        break;
                    case 'time_slow':
                        document.body.style.filter = 'none';
                        break;
                }
                
                addNotification(`${powerUp.icon} ${powerUp.name} expired`, 'warning');
            }, powerUp.duration);
        }
        
        function checkForPowerUpTrigger() {
            // Trigger power-ups based on performance
            if (gameState.player.streak === 5) {
                triggerPowerUp('combo_boost');
            } else if (gameState.player.streak === 10) {
                triggerPowerUp('double_score');
            } else if (gameState.player.streak === 15) {
                triggerPowerUp('perfect_streak');
            }
            
            // Random power-up chance
            if (Math.random() < 0.05) { // 5% chance per question
                const availablePowerUps = gameState.engagement.powerUps.filter(p => 
                    !gameState.engagement.currentPowerUp || p.id !== gameState.engagement.currentPowerUp.id
                );
                const randomPowerUp = availablePowerUps[Math.floor(Math.random() * availablePowerUps.length)];
                triggerPowerUp(randomPowerUp.id);
            }
        }
        
        function showStreakEffect(streak) {
            if (streak >= 3) {
                const streakMessages = [
                    `🔥 ${streak} in a row! You're on fire!`,
                    `⚡ ${streak} streak! Unstoppable!`,
                    `🌟 ${streak} correct! Amazing!`,
                    `🚀 ${streak} perfect! Keep going!`
                ];
                const message = streakMessages[Math.min(streak - 3, streakMessages.length - 1)];
                addNotification(message, 'success');
                
                // Visual streak effect
                showComboEffect(streak, window.innerWidth / 2, window.innerHeight / 3);
            }
        }
        
        function adaptDifficulty() {
            const accuracy = gameState.player.accuracy;
            const currentLevel = gameState.player.level;
            
            // Adaptive difficulty based on performance
            if (accuracy > 85 && currentLevel > 3) {
                gameState.engagement.difficulty = 'hard';
                addNotification('🔥 Difficulty increased! More challenging questions ahead!', 'warning');
            } else if (accuracy < 50 && currentLevel > 1) {
                gameState.engagement.difficulty = 'easy';
                addNotification('📚 Difficulty adjusted to help you learn better!', 'info');
            } else {
                gameState.engagement.difficulty = 'normal';
            }
        }
        
        // Continuous Animation Loop
        function animationLoop() {
            updateParticles();
            renderParticles();
            
            // Continue animation loop
            requestAnimationFrame(animationLoop);
        }
        
        // Advanced Inventory System
        function initializeInventorySystem() {
            console.log('🎒 Initializing Inventory System...');
            
            // Reset inventory to default state
            gameState.inventory.items = [];
            gameState.inventory.currency.coins = 100;
            gameState.inventory.currency.gems = 5;
            gameState.inventory.currency.awsCredits = 10;
            
            // Initialize starting items
            const startingItems = [
                createItem('health_potion', 'Health Potion', 'consumables', 'Restores 50 HP', 3, '🧪'),
                createItem('mana_potion', 'Mana Potion', 'consumables', 'Restores 30 MP', 2, '💙'),
                createItem('basic_sword', 'Basic Sword', 'equipment', 'Basic weapon for AWS warriors', 1, '⚔️'),
                createItem('study_guide', 'AWS Study Guide', 'materials', 'Increases learning speed by 10%', 1, '📚')
            ];
            
            startingItems.forEach(item => {
                try {
                    addItemToInventory(item);
                } catch (error) {
                    console.error('Error adding item to inventory:', error);
                }
            });
            
            console.log('✅ Inventory system initialized');
        }
        
        function createItem(id, name, category, description, quantity, icon, rarity = 'common', stats = {}) {
            return {
                id: id,
                name: name,
                category: category,
                description: description,
                quantity: quantity,
                icon: icon,
                rarity: rarity,
                stats: stats, // { attack: 5, defense: 3, hp: 50, mp: 30, etc }
                value: calculateItemValue(category, rarity, stats),
                stackable: category === 'consumables' || category === 'materials',
                createdAt: Date.now()
            };
        }
        
        function calculateItemValue(category, rarity, stats) {
            const baseValues = {
                'consumables': 10,
                'equipment': 50,
                'materials': 20,
                'special': 100
            };
            
            const rarityMultipliers = {
                'common': 1,
                'uncommon': 2,
                'rare': 4,
                'epic': 8,
                'legendary': 16
            };
            
            const statsValue = Object.values(stats).reduce((sum, stat) => sum + stat, 0) * 5;
            
            return Math.floor((baseValues[category] + statsValue) * rarityMultipliers[rarity]);
        }
        
        function addItemToInventory(item) {
            // Ensure inventory structure exists
            if (!gameState.inventory || !gameState.inventory.items) {
                console.error('Inventory not initialized');
                return false;
            }
            
            // Check if inventory is full
            if (gameState.inventory.items.length >= gameState.inventory.capacity) {
                console.warn('Inventory full! Cannot add more items.');
                return false;
            }
            
            // Check if item is stackable and already exists
            if (item.stackable) {
                const existingItem = gameState.inventory.items.find(i => i.id === item.id);
                if (existingItem) {
                    existingItem.quantity += item.quantity;
                    addNotification(`${item.icon} ${item.name} x${item.quantity} added`, 'success');
                    return true;
                }
            }
            
            // Add new item
            gameState.inventory.items.push(item);
            addNotification(`${item.icon} ${item.name} acquired!`, 'success');
            
            // Create acquisition particle effect
            createParticle(
                window.innerWidth - 100,
                100,
                'item_acquired',
                {
                    text: item.icon,
                    color: getRarityColor(item.rarity),
                    duration: 2000,
                    velocityX: -1,
                    velocityY: -2
                }
            );
            
            return true;
        }
        
        function removeItemFromInventory(itemId, quantity = 1) {
            const item = gameState.inventory.items.find(i => i.id === itemId);
            if (!item) return false;
            
            if (item.quantity <= quantity) {
                // Remove item completely
                gameState.inventory.items = gameState.inventory.items.filter(i => i.id !== itemId);
                addNotification(`${item.icon} ${item.name} removed`, 'info');
            } else {
                // Reduce quantity
                item.quantity -= quantity;
                addNotification(`${item.icon} ${item.name} x${quantity} used`, 'info');
            }
            
            return true;
        }
        
        function useItem(itemId) {
            const item = gameState.inventory.items.find(i => i.id === itemId);
            if (!item) return false;
            
            let used = false;
            
            switch (item.id) {
                case 'health_potion':
                    if (gameState.player.hp < gameState.player.maxHp) {
                        gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + 50);
                        showHealingNumber(50, gameState.player.x, gameState.player.y - 30);
                        playSound('heal');
                        used = true;
                    }
                    break;
                    
                case 'mana_potion':
                    if (gameState.player.mp < gameState.player.maxMp) {
                        gameState.player.mp = Math.min(gameState.player.maxMp, gameState.player.mp + 30);
                        addEffect(gameState.player.x, gameState.player.y - 50, '+30 MP', '#00ccff', 20);
                        playSound('heal');
                        used = true;
                    }
                    break;
                    
                case 'study_guide':
                    // Temporary XP boost
                    const xpBoost = Math.floor(gameState.player.level * 5);
                    gameState.player.exp += xpBoost;
                    addEffect(gameState.player.x, gameState.player.y - 70, `+${xpBoost} XP`, '#ffcc00', 24);
                    playSound('levelup');
                    used = true;
                    break;
            }
            
            if (used) {
                removeItemFromInventory(itemId, 1);
                return true;
            }
            
            return false;
        }
        
        function equipItem(itemId) {
            const item = gameState.inventory.items.find(i => i.id === itemId);
            if (!item || item.category !== 'equipment') return false;
            
            // Determine equipment slot
            let slot = null;
            if (item.id.includes('sword') || item.id.includes('staff')) slot = 'weapon';
            else if (item.id.includes('armor') || item.id.includes('robe')) slot = 'armor';
            else if (item.id.includes('ring') || item.id.includes('amulet')) slot = 'accessory';
            
            if (!slot) return false;
            
            // Unequip current item if exists
            if (gameState.inventory.equipped[slot]) {
                unequipItem(slot);
            }
            
            // Equip new item
            gameState.inventory.equipped[slot] = item;
            
            // Apply stats
            applyItemStats(item, true);
            
            addNotification(`${item.icon} ${item.name} equipped!`, 'success');
            return true;
        }
        
        function unequipItem(slot) {
            const item = gameState.inventory.equipped[slot];
            if (!item) return false;
            
            // Remove stats
            applyItemStats(item, false);
            
            // Unequip
            gameState.inventory.equipped[slot] = null;
            
            addNotification(`${item.icon} ${item.name} unequipped`, 'info');
            return true;
        }
        
        function applyItemStats(item, apply) {
            const multiplier = apply ? 1 : -1;
            
            if (item.stats.attack) {
                // Apply attack bonus (affects damage)
                gameState.player.attackBonus = (gameState.player.attackBonus || 0) + (item.stats.attack * multiplier);
            }
            
            if (item.stats.defense) {
                // Apply defense bonus (reduces damage taken)
                gameState.player.defenseBonus = (gameState.player.defenseBonus || 0) + (item.stats.defense * multiplier);
            }
            
            if (item.stats.hp) {
                // Apply HP bonus
                const hpBonus = item.stats.hp * multiplier;
                gameState.player.maxHp += hpBonus;
                if (apply) {
                    gameState.player.hp += hpBonus;
                } else {
                    gameState.player.hp = Math.min(gameState.player.hp, gameState.player.maxHp);
                }
            }
            
            if (item.stats.mp) {
                // Apply MP bonus
                const mpBonus = item.stats.mp * multiplier;
                gameState.player.maxMp += mpBonus;
                if (apply) {
                    gameState.player.mp += mpBonus;
                } else {
                    gameState.player.mp = Math.min(gameState.player.mp, gameState.player.maxMp);
                }
            }
        }
        
        function getRarityColor(rarity) {
            const colors = {
                'common': '#ffffff',
                'uncommon': '#00ff00',
                'rare': '#0066ff',
                'epic': '#cc00ff',
                'legendary': '#ffcc00'
            };
            return colors[rarity] || colors['common'];
        }
        
        function awardRandomItem() {
            const itemPool = [
                { id: 'health_potion', weight: 30 },
                { id: 'mana_potion', weight: 25 },
                { id: 'aws_token', weight: 20 },
                { id: 'study_guide', weight: 15 },
                { id: 'rare_gem', weight: 8 },
                { id: 'legendary_scroll', weight: 2 }
            ];
            
            const totalWeight = itemPool.reduce((sum, item) => sum + item.weight, 0);
            let random = Math.random() * totalWeight;
            
            for (const itemData of itemPool) {
                random -= itemData.weight;
                if (random <= 0) {
                    const item = createRewardItem(itemData.id);
                    if (item) {
                        addItemToInventory(item);
                        return item;
                    }
                    break;
                }
            }
            
            return null;
        }
        
        function createRewardItem(itemId) {
            const itemDefinitions = {
                'health_potion': () => createItem('health_potion', 'Health Potion', 'consumables', 'Restores 50 HP', 1, '🧪'),
                'mana_potion': () => createItem('mana_potion', 'Mana Potion', 'consumables', 'Restores 30 MP', 1, '💙'),
                'aws_token': () => createItem('aws_token', 'AWS Token', 'materials', 'Valuable AWS certification token', 1, '🪙', 'uncommon'),
                'study_guide': () => createItem('study_guide', 'AWS Study Guide', 'materials', 'Increases learning speed', 1, '📚'),
                'rare_gem': () => createItem('rare_gem', 'Rare Gem', 'special', 'A precious gem with unknown powers', 1, '💎', 'rare'),
                'legendary_scroll': () => createItem('legendary_scroll', 'Legendary Scroll', 'special', 'Ancient AWS wisdom', 1, '📜', 'legendary')
            };
            
            const createFunc = itemDefinitions[itemId];
            return createFunc ? createFunc() : null;
        }
        
        function addCurrency(type, amount) {
            if (gameState.inventory.currency[type] !== undefined) {
                gameState.inventory.currency[type] += amount;
                
                const icons = {
                    'coins': '🪙',
                    'gems': '💎',
                    'awsCredits': '☁️'
                };
                
                addNotification(`${icons[type]} +${amount} ${type}`, 'success');
                return true;
            }
            return false;
        }
        
        function showInventoryUI() {
            // Create inventory modal
            const modal = document.createElement('div');
            modal.className = 'inventory-modal';
            modal.innerHTML = `
                <div class="inventory-content">
                    <div class="inventory-header">
                        <h2>🎒 Inventory</h2>
                        <span class="inventory-close">&times;</span>
                    </div>
                    <div class="inventory-currency">
                        <span>🪙 ${gameState.inventory.currency.coins}</span>
                        <span>💎 ${gameState.inventory.currency.gems}</span>
                        <span>☁️ ${gameState.inventory.currency.awsCredits}</span>
                    </div>
                    <div class="inventory-grid" id="inventory-grid"></div>
                    <div class="inventory-equipped">
                        <h3>Equipped</h3>
                        <div class="equipped-slots">
                            <div class="equipped-slot weapon">Weapon: ${gameState.inventory.equipped.weapon ? gameState.inventory.equipped.weapon.name : 'None'}</div>
                            <div class="equipped-slot armor">Armor: ${gameState.inventory.equipped.armor ? gameState.inventory.equipped.armor.name : 'None'}</div>
                            <div class="equipped-slot accessory">Accessory: ${gameState.inventory.equipped.accessory ? gameState.inventory.equipped.accessory.name : 'None'}</div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Populate inventory grid
            const grid = document.getElementById('inventory-grid');
            gameState.inventory.items.forEach(item => {
                const itemElement = document.createElement('div');
                itemElement.className = `inventory-item ${item.rarity}`;
                itemElement.innerHTML = `
                    <div class="item-icon">${item.icon}</div>
                    <div class="item-name">${item.name}</div>
                    <div class="item-quantity">${item.quantity > 1 ? `x${item.quantity}` : ''}</div>
                `;
                
                itemElement.addEventListener('click', () => {
                    if (item.category === 'consumables') {
                        useItem(item.id);
                    } else if (item.category === 'equipment') {
                        equipItem(item.id);
                    }
                    // Refresh inventory display
                    modal.remove();
                    showInventoryUI();
                });
                
                grid.appendChild(itemElement);
            });
            
            // Close modal
            modal.querySelector('.inventory-close').addEventListener('click', () => {
                modal.remove();
            });
            
            // Close on outside click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        // AWS Components System
        const AWS_COMPONENTS = {
            'compute': {
                icon: '⚙️',
                title: 'Compute Services',
                description: 'EC2, Lambda, ECS, and compute solutions',
                categories: ['EC2', 'Lambda', 'ECS', 'Fargate', 'Batch', 'Elastic Beanstalk']
            },
            'storage': {
                icon: '💾',
                title: 'Storage Services',
                description: 'S3, EBS, EFS, and storage solutions',
                categories: ['S3', 'EBS', 'EFS', 'FSx', 'Storage Gateway', 'Snow Family']
            },
            'database': {
                icon: '🗄️',
                title: 'Database Services',
                description: 'RDS, DynamoDB, and database solutions',
                categories: ['RDS', 'DynamoDB', 'Aurora', 'ElastiCache', 'Neptune', 'DocumentDB']
            },
            'networking': {
                icon: '🌐',
                title: 'Networking & CDN',
                description: 'VPC, CloudFront, and network solutions',
                categories: ['VPC', 'CloudFront', 'Route 53', 'API Gateway', 'Load Balancer', 'Direct Connect']
            },
            'security': {
                icon: '🔒',
                title: 'Security & Identity',
                description: 'IAM, KMS, and security solutions',
                categories: ['IAM', 'KMS', 'Certificate Manager', 'WAF', 'GuardDuty', 'Inspector']
            },
            'analytics': {
                icon: '📊',
                title: 'Analytics & ML',
                description: 'SageMaker, EMR, and analytics solutions',
                categories: ['SageMaker', 'EMR', 'Kinesis', 'Athena', 'QuickSight', 'Glue']
            },
            'monitoring': {
                icon: '📈',
                title: 'Monitoring & Management',
                description: 'CloudWatch, CloudTrail, and monitoring solutions',
                categories: ['CloudWatch', 'CloudTrail', 'Config', 'Systems Manager', 'X-Ray', 'CloudFormation']
            },
            'integration': {
                icon: '🔗',
                title: 'Integration Services',
                description: 'SQS, SNS, and integration solutions',
                categories: ['SQS', 'SNS', 'SES', 'EventBridge', 'Step Functions', 'AppSync']
            }
        };
        
        function showComponentsScreen() {
            // Hide welcome screen
            document.getElementById('welcome-screen').classList.add('hidden');
            
            // Show components screen
            document.getElementById('components-screen').classList.remove('hidden');
            
            // Populate components grid
            const grid = document.getElementById('components-grid');
            grid.innerHTML = '';
            
            Object.entries(AWS_COMPONENTS).forEach(([key, component]) => {
                const card = document.createElement('div');
                card.className = 'component-card';
                card.innerHTML = `
                    <div class="component-icon">${component.icon}</div>
                    <div class="component-title">${component.title}</div>
                    <div class="component-description">${component.description}</div>
                    <div class="component-count">${component.categories.length} Services</div>
                `;
                
                card.addEventListener('click', () => {
                    startComponentQuiz(key);
                });
                
                grid.appendChild(card);
            });
        }
        
        function startComponentQuiz(componentKey) {
            const component = AWS_COMPONENTS[componentKey];
            
            // Set up the game state for this component
            gameState.currentComponent = componentKey;
            gameState.componentData = component;
            
            // Show transition message
            showScreenTransition(`Starting ${component.title} Quiz...`, 1500);
            
            // Start the battle with component-specific settings
            setTimeout(() => {
                gameState.currentStage = 'battle';
                gameState.isInBattle = true;
                
                // Hide components screen
                document.getElementById('components-screen').classList.add('hidden');
                
                // Show game HUD and battle screen
                document.getElementById('pixel-hud').style.display = 'block';
                document.getElementById('battle-screen').classList.add('active');
                document.getElementById('level-indicator').style.display = 'block';
                document.getElementById('abilities-panel').classList.add('active');
                
                // Update UI for component quiz
                document.getElementById('current-level-display').textContent = `${component.title}`;
                document.getElementById('current-level-name').textContent = 'Component Quiz';
                
                // Load first question
                loadQuestion();
                
                // Start appropriate music
                playMusic('battle');
            }, 1500);
        }
        
        function backFromComponents() {
            document.getElementById('components-screen').classList.add('hidden');
            document.getElementById('welcome-screen').classList.remove('hidden');
        }
        
        function updateBattleEmojis() {
            const currentLevel = LEVELS[gameState.currentLevel - 1];
            if (!currentLevel) return;
            
            // Find or create emoji containers in the battle screen
            let playerEmojiContainer = document.getElementById('player-emoji');
            let enemyEmojiContainer = document.getElementById('enemy-emoji');
            
            if (!playerEmojiContainer) {
                playerEmojiContainer = document.createElement('div');
                playerEmojiContainer.id = 'player-emoji';
                playerEmojiContainer.className = 'battle-emoji player';
                
                enemyEmojiContainer = document.createElement('div');
                enemyEmojiContainer.id = 'enemy-emoji';
                enemyEmojiContainer.className = 'battle-emoji enemy';
                
                // Add to battle screen
                const battleScreen = document.getElementById('battle-screen');
                const battleContainer = document.createElement('div');
                battleContainer.className = 'battle-emojis-container';
                battleContainer.style.textAlign = 'center';
                battleContainer.style.marginBottom = '20px';
                
                battleContainer.appendChild(playerEmojiContainer);
                battleContainer.appendChild(document.createTextNode(' VS '));
                battleContainer.appendChild(enemyEmojiContainer);
                
                battleScreen.insertBefore(battleContainer, battleScreen.firstChild);
            }
            
            // Update emoji content
            playerEmojiContainer.textContent = currentLevel.playerEmoji;
            enemyEmojiContainer.textContent = currentLevel.enemyEmoji;
        }
        
        // Initialize Pixel Art Game
        function initializeGame() {
            console.log('🎮 Initializing AWS Quest Pixel Adventure...');
            
            // Get canvas and context
            gameState.canvas = document.getElementById('game-canvas');
            gameState.ctx = gameState.canvas.getContext('2d');
            
            // Disable image smoothing for pixel art
            gameState.ctx.imageSmoothingEnabled = false;
            gameState.ctx.webkitImageSmoothingEnabled = false;
            gameState.ctx.mozImageSmoothingEnabled = false;
            gameState.ctx.msImageSmoothingEnabled = false;
            
            // Start game loop
            gameLoop();
            
            // Initialize authentication and save system
            initializeAuth();
            
            // Initialize progress tracking
            initializeProgressTracking();
            
            // Initialize challenge system
            initializeChallengeSystem();
            
            // Initialize audio system
            initializeAudioSystem();
            
            // Initialize animation system
            initializeAnimationSystem();
            
            // Initialize engagement system
            initializeEngagementSystem();
            
            // Initialize inventory system
            initializeInventorySystem();
            
            // Start animation loop
            animationLoop();
            
            // Apply UI animations
            setTimeout(() => {
                applyUIAnimations();
            }, 500);
            
            // Start welcome music
            setTimeout(() => {
                playMusic('menu');
            }, 1000);
            
            // Update audio UI
            updateAudioUI();
            
            console.log('✅ Pixel Adventure initialized successfully!');
        }

        // Authentication & Save System Functions
        async function initializeAuth() {
            // Check for existing token
            if (gameState.userToken) {
                try {
                    const response = await fetch('/api/game/load-progress', {
                        headers: {
                            'Authorization': `Bearer ${gameState.userToken}`,
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success) {
                            loadGameProgress(data.progress);
                            gameState.isAuthenticated = true;
                            startAutoSave();
                            addNotification('Welcome back! Progress loaded.', 'success');
                        }
                    } else {
                        localStorage.removeItem('userToken');
                        gameState.userToken = null;
                    }
                } catch (error) {
                    console.error('Auth initialization error:', error);
                }
            }
        }

        function loadGameProgress(progress) {
            if (!progress) return;
            
            // Load player data
            gameState.player.level = progress.level || 1;
            gameState.player.exp = progress.experience || 0;
            gameState.player.score = progress.totalScore || 0;
            gameState.player.gamesPlayed = progress.gamesPlayed || 0;
            gameState.player.totalQuestions = progress.totalQuestions || 0;
            gameState.player.correctAnswers = progress.correctAnswers || 0;
            gameState.player.levelsCompleted = progress.levelsCompleted || [];
            gameState.player.achievements = progress.achievements || [];
            gameState.player.settings = { ...gameState.player.settings, ...progress.settings };
            gameState.maxCombo = progress.maxCombo || 0;
            gameState.specialAbilities = { ...gameState.specialAbilities, ...progress.specialAbilities };
            gameState.inventory = progress.inventory || [];
            
            // Update accuracy
            if (gameState.player.totalQuestions > 0) {
                gameState.player.accuracy = Math.round((gameState.player.correctAnswers / gameState.player.totalQuestions) * 100);
            }
            
            gameState.lastSaveTime = progress.lastSave;
            updateUI();
        }

        async function saveGameProgress() {
            if (!gameState.isAuthenticated || gameState.saveInProgress) {
                gameState.pendingSave = true;
                return;
            }
            
            gameState.saveInProgress = true;
            
            try {
                const progressData = {
                    level: gameState.player.level,
                    experience: gameState.player.exp,
                    totalScore: gameState.player.score,
                    maxCombo: gameState.maxCombo,
                    gamesPlayed: gameState.player.gamesPlayed,
                    totalQuestions: gameState.player.totalQuestions,
                    correctAnswers: gameState.player.correctAnswers,
                    levelsCompleted: gameState.player.levelsCompleted,
                    achievements: gameState.player.achievements,
                    specialAbilities: gameState.specialAbilities,
                    inventory: gameState.inventory,
                    settings: gameState.player.settings
                };
                
                const response = await fetch('/api/game/save-progress', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${gameState.userToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(progressData)
                });
                
                if (response.ok) {
                    gameState.lastSaveTime = Date.now();
                    addNotification('Game saved!', 'success');
                } else {
                    throw new Error('Save failed');
                }
            } catch (error) {
                console.error('Save error:', error);
                addNotification('Save failed!', 'error');
                gameState.pendingSave = true;
            }
            
            gameState.saveInProgress = false;
            
            // If there's a pending save, execute it
            if (gameState.pendingSave) {
                gameState.pendingSave = false;
                setTimeout(() => saveGameProgress(), 1000);
            }
        }

        function startAutoSave() {
            // Auto-saving disabled - only manual saves allowed
            console.log('🚫 Auto-saving disabled - manual saves only');
        }

        function addNotification(message, type = 'info') {
            const notification = {
                id: Date.now(),
                message,
                type,
                timestamp: Date.now()
            };
            
            gameState.notifications.push(notification);
            
            // Create visual notification with enhanced styling
            const notificationElement = document.createElement('div');
            notificationElement.className = `notification ${type}`;
            notificationElement.id = `notification-${notification.id}`;
            
            // Add icon based on type
            const iconMap = {
                'success': '✅',
                'error': '❌',
                'warning': '⚠️',
                'info': 'ℹ️'
            };
            
            notificationElement.innerHTML = `
                <span class="notification-icon">${iconMap[type] || 'ℹ️'}</span>
                <span class="notification-text">${message}</span>
                <span class="notification-close" onclick="closeNotification('${notification.id}')">&times;</span>
            `;
            
            const container = document.getElementById('notification-container');
            container.appendChild(notificationElement);
            
            // Play notification sound
            playSound('notification');
            
            // Auto-remove notification after 4 seconds
            setTimeout(() => {
                closeNotification(notification.id);
            }, 4000);
            
            // Also log to console for debugging
            console.log(`🔔 ${type.toUpperCase()}: ${message}`);
        }
        
        function closeNotification(notificationId) {
            const notificationElement = document.getElementById(`notification-${notificationId}`);
            if (notificationElement) {
                notificationElement.classList.add('fadeOut');
                setTimeout(() => {
                    if (notificationElement.parentNode) {
                        notificationElement.parentNode.removeChild(notificationElement);
                    }
                }, 300);
            }
            gameState.notifications = gameState.notifications.filter(n => n.id !== notificationId);
        }

        // Main Game Loop
        function gameLoop() {
            // Clear canvas
            gameState.ctx.fillStyle = '#0f0f23';
            gameState.ctx.fillRect(0, 0, gameState.canvas.width, gameState.canvas.height);
            
            // Draw background
            drawBackground();
            
            // Update and draw game objects based on current stage
            switch(gameState.currentStage) {
                case 'welcome':
                    // Welcome screen is handled by HTML
                    break;
                case 'battle':
                    updateBattle();
                    drawBattle();
                    break;
                case 'victory':
                    drawVictory();
                    break;
                case 'defeat':
                    drawDefeat();
                    break;
            }
            
            // Update effects
            updateEffects();
            drawEffects();
            
            // Continue loop
            gameState.animationFrame = requestAnimationFrame(gameLoop);
        }

        // Draw Pixel Art Background
        function drawBackground() {
            const ctx = gameState.ctx;
            const level = LEVELS[gameState.currentLevel - 1];
            
            if (!level) return;
            
            // Draw background pattern based on level
            switch(level.background) {
                case 'forest':
                    // Green forest background with trees
                    ctx.fillStyle = '#228B22';
                    ctx.fillRect(0, 400, 800, 200);
                    
                    // Draw trees
                    for (let i = 0; i < 5; i++) {
                        const x = i * 160 + 50;
                        drawTree(x, 350);
                    }
                    break;
                    
                case 'cave':
                    // Dark cave background
                    ctx.fillStyle = '#2F2F2F';
                    ctx.fillRect(0, 400, 800, 200);
                    
                    // Draw cave walls
                    ctx.fillStyle = '#1C1C1C';
                    ctx.fillRect(0, 0, 50, 600);
                    ctx.fillRect(750, 0, 50, 600);
                    break;
                    
                case 'castle':
                    // Castle background
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(0, 400, 800, 200);
                    
                    // Draw castle walls
                    ctx.fillStyle = '#696969';
                    for (let i = 0; i < 3; i++) {
                        const x = i * 250 + 100;
                        drawCastleWall(x, 300);
                    }
                    break;
            }
            
            // Draw clouds
            ctx.fillStyle = '#87CEEB';
            for (let i = 0; i < 4; i++) {
                const x = i * 200 + 50;
                const y = 50 + Math.sin(Date.now() * 0.001 + i) * 20;
                drawCloud(x, y);
            }
        }

        // Draw Tree (Pixel Art)
        function drawTree(x, y) {
            const ctx = gameState.ctx;
            
            // Trunk
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x + 16, y + 32, 16, 48);
            
            // Leaves
            ctx.fillStyle = '#228B22';
            ctx.fillRect(x, y, 48, 48);
            
            // Tree top
            ctx.fillStyle = '#32CD32';
            ctx.fillRect(x + 8, y - 8, 32, 24);
        }

        // Draw Cloud (Pixel Art)
        function drawCloud(x, y) {
            const ctx = gameState.ctx;
            ctx.fillStyle = '#FFFFFF';
            
            // Cloud parts
            ctx.fillRect(x, y + 8, 64, 16);
            ctx.fillRect(x + 8, y, 48, 32);
            ctx.fillRect(x + 16, y - 8, 32, 24);
        }

        // Draw Castle Wall
        function drawCastleWall(x, y) {
            const ctx = gameState.ctx;
            
            // Main wall
            ctx.fillStyle = '#696969';
            ctx.fillRect(x, y, 80, 100);
            
            // Battlements
            ctx.fillRect(x, y - 16, 16, 16);
            ctx.fillRect(x + 32, y - 16, 16, 16);
            ctx.fillRect(x + 64, y - 16, 16, 16);
        }

        // Draw Battle Scene
        function drawBattle() {
            const ctx = gameState.ctx;
            
            // Draw player character
            drawCharacter(gameState.player);
            
            // Draw enemy
            if (gameState.enemy.isAlive) {
                drawCharacter(gameState.enemy);
            }
            
            // Draw health bars above characters
            drawHealthBar(gameState.player.x, gameState.player.y - 40, 
                         gameState.player.hp, gameState.player.maxHp, '#ff0044');
            
            if (gameState.enemy.isAlive) {
                drawHealthBar(gameState.enemy.x, gameState.enemy.y - 40, 
                             gameState.enemy.hp, gameState.enemy.maxHp, '#ff0044');
            }
        }

        // Draw Pixel Art Character
        function drawCharacter(character) {
            const ctx = gameState.ctx;
            
            // Get current sprite based on animation frame
            const spriteType = character.sprite;
            const spriteSet = SPRITES[spriteType];
            
            if (!spriteSet) return;
            
            // Determine current animation state
            let currentAnimation = 'idle';
            
            // Simple animated sprite selection
            const frameIndex = Math.floor(Date.now() / 500) % spriteSet.idle.length;
            const sprite = spriteSet[currentAnimation][frameIndex];
            
            // Draw sprite (using emoji as pixel art)
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(sprite, character.x, character.y);
            
            // Draw character shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(character.x - 24, character.y + 20, 48, 8);
        }

        // Draw Health Bar
        function drawHealthBar(x, y, currentHp, maxHp, color) {
            const ctx = gameState.ctx;
            const barWidth = 60;
            const barHeight = 8;
            
            // Background
            ctx.fillStyle = '#333333';
            ctx.fillRect(x - barWidth/2, y, barWidth, barHeight);
            
            // Health fill
            const healthPercent = currentHp / maxHp;
            ctx.fillStyle = color;
            ctx.fillRect(x - barWidth/2, y, barWidth * healthPercent, barHeight);
            
            // Border
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(x - barWidth/2, y, barWidth, barHeight);
        }

        // Update Battle Logic
        function updateBattle() {
            // Animate characters
            gameState.player.animationFrame++;
            gameState.enemy.animationFrame++;
            
            // Simple breathing animation
            const breathe = Math.sin(Date.now() * 0.003) * 2;
            gameState.player.y = 400 + breathe;
            gameState.enemy.y = 400 - breathe;
        }

        // Draw Effects System
        function drawEffects() {
            const ctx = gameState.ctx;
            
            gameState.effects.forEach(effect => {
                ctx.font = `${effect.size}px Arial`;
                ctx.fillStyle = effect.color;
                ctx.textAlign = 'center';
                ctx.globalAlpha = effect.opacity;
                ctx.fillText(effect.text, effect.x, effect.y);
                ctx.globalAlpha = 1;
            });
        }

        // Update Effects
        function updateEffects() {
            for (let i = gameState.effects.length - 1; i >= 0; i--) {
                const effect = gameState.effects[i];
                effect.y -= effect.speed;
                effect.opacity -= 0.02;
                effect.life--;
                
                if (effect.life <= 0 || effect.opacity <= 0) {
                    gameState.effects.splice(i, 1);
                }
            }
        }

        // Add Effect
        function addEffect(x, y, text, color = '#ffffff', size = 24) {
            gameState.effects.push({
                x: x,
                y: y,
                text: text,
                color: color,
                size: size,
                opacity: 1,
                speed: 2,
                life: 60
            });
        }

        // Draw Victory Screen
        function drawVictory() {
            const ctx = gameState.ctx;
            
            // Victory background
            ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
            ctx.fillRect(0, 0, 800, 600);
            
            // Victory text
            ctx.font = '48px Press Start 2P';
            ctx.fillStyle = '#00ff00';
            ctx.textAlign = 'center';
            ctx.fillText('VICTORY!', 400, 300);
        }

        // Draw Defeat Screen  
        function drawDefeat() {
            const ctx = gameState.ctx;
            
            // Defeat background
            ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
            ctx.fillRect(0, 0, 800, 600);
            
            // Defeat text
            ctx.font = '48px Press Start 2P';
            ctx.fillStyle = '#ff0000';
            ctx.textAlign = 'center';
            ctx.fillText('DEFEAT!', 400, 300);
        }

        // Game Control Functions
        function startBattle() {
            gameState.currentStage = 'battle';
            gameState.isInBattle = true;
            
            // Show screen transition
            showScreenTransition('🎮 Starting Battle...', 1500);
            
            setTimeout(() => {
                // Hide welcome screen
                document.getElementById('welcome-screen').classList.add('hidden');
                
                // Show game HUD and battle screen
                document.getElementById('pixel-hud').style.display = 'block';
                document.getElementById('battle-screen').classList.add('active');
                document.getElementById('level-indicator').style.display = 'block';
                document.getElementById('abilities-panel').classList.add('active');
            }, 200);
            
            // Update level indicator
            const currentLevel = LEVELS[gameState.currentLevel - 1];
            document.getElementById('current-level-display').textContent = gameState.currentLevel;
            document.getElementById('current-level-name').textContent = currentLevel.name;
            
            // Initialize battle type based on level
            let battleType = 'normal';
            if (gameState.currentLevel === 2) battleType = 'speed';
            if (gameState.currentLevel === 3) battleType = 'boss';
            
            initializeBattleType(battleType);
            
            // Switch to appropriate battle music
            if (gameState.currentLevel >= 8) {
                playMusic('boss');
            } else {
                playMusic('battle');
            }
            
            // Load first question
            loadQuestion();
            
            // Update battle emojis
            updateBattleEmojis();
            
            console.log(`🎯 Battle started! Level ${gameState.currentLevel}: ${currentLevel.name} (${battleType.toUpperCase()})`);
        }

        async function loadQuestion() {
            try {
                // Record question start time for response time tracking
                gameState.questionStartTime = Date.now();
                
                const currentLevel = LEVELS[gameState.currentLevel - 1];
                if (!currentLevel) return;
                
                // Build query parameters
                const params = new URLSearchParams({
                    difficulty: currentLevel.questionDifficulty
                });
                
                // Add category filter if not mixed
                if (currentLevel.category && currentLevel.category !== 'Mixed') {
                    params.append('category', currentLevel.category);
                }
                
                // Fetch question from server
                const response = await fetch(`/api/game/question/session_${Date.now()}?${params}`, {
                    headers: gameState.isAuthenticated ? {
                        'Authorization': `Bearer ${gameState.userToken}`
                    } : {}
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        gameState.currentQuestion = data.question;
                        updateQuestionUI(data.question);
                        return;
                    }
                }
                
                // Fallback to local questions
                const questionData = getRandomAWSQuestion();
                gameState.currentQuestion = questionData;
                updateQuestionUI(questionData);
                
            } catch (error) {
                console.error('Error loading question:', error);
                // Fallback to local questions
                const questionData = getRandomAWSQuestion();
                gameState.currentQuestion = questionData;
                updateQuestionUI(questionData);
            }
        }
        
        function updateQuestionUI(questionData) {
            // Update UI
            document.getElementById('question-text').textContent = questionData.question;
            
            const options = document.querySelectorAll('.pixel-option');
            options.forEach((option, index) => {
                option.textContent = `${String.fromCharCode(65 + index)}. ${questionData.options[index]}`;
                option.classList.remove('selected', 'correct', 'incorrect');
                option.disabled = false;
            });
            
            // Reset attack button
            document.getElementById('attack-btn').disabled = true;
            gameState.selectedAnswer = null;
            
            // Start question timer for engagement scoring
            gameState.questionStartTime = Date.now();
        }

        function selectOption(index) {
            // Prevenir selección múltiple y asegurar que el juego no esté trabado
            if (gameState.selectedAnswer !== null) {
                console.log('Answer already selected, ignoring');
                return;
            }
            
            // Play click sound
            playSound('click');
            
            // Clear previous selections
            document.querySelectorAll('.pixel-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            
            // Select new option
            const selectedOption = document.querySelectorAll('.pixel-option')[index];
            if (selectedOption) {
                selectedOption.classList.add('selected');
                gameState.selectedAnswer = index;
                document.getElementById('attack-btn').disabled = false;
                console.log(`🎯 Option selected: ${index}`);
            }
        }

        function attack() {
            // Verificar que haya una respuesta seleccionada
            if (gameState.selectedAnswer === null || gameState.selectedAnswer === undefined) {
                console.log('No answer selected, cannot attack');
                return;
            }
            
            console.log(`💪 Attacking with answer: ${gameState.selectedAnswer}`);
            
            const isCorrect = gameState.selectedAnswer === gameState.currentQuestion.correct;
            
            // Visual feedback with animations
            document.querySelectorAll('.pixel-option').forEach((btn, index) => {
                if (index === gameState.currentQuestion.correct) {
                    btn.classList.add('correct');
                    // Animate correct button
                    animateAnswerSelection(btn, true);
                } else if (index === gameState.selectedAnswer && !isCorrect) {
                    btn.classList.add('incorrect');
                    // Animate incorrect button
                    animateAnswerSelection(btn, false);
                }
                btn.disabled = true;
            });
            
            // Update combo system
            updateCombo(isCorrect);
            
            // Battle effects with audio
            if (isCorrect) {
                performAttack();
                gameState.player.correctAnswers++;
                
                // Play correct sound
                playSound('correct');
                
                // Calculate enhanced engagement score
                const responseTime = gameState.questionStartTime ? Date.now() - gameState.questionStartTime : 5000;
                let scoreGain = calculateEngagementScore(isCorrect, responseTime);
                
                // Show streak effects
                gameState.player.streak++;
                showStreakEffect(gameState.player.streak);
                
                // Check for power-up triggers
                checkForPowerUpTrigger();
                
                // Show motivational message occasionally
                if (Math.random() < 0.3) {
                    showMotivationalMessage();
                }
                
                gameState.player.score += scoreGain;
                addEffect(gameState.enemy.x, gameState.enemy.y - 60, `+${scoreGain} XP`, '#ffcc00', 20);
                
                // Award coins for correct answers
                const coinReward = Math.floor(scoreGain / 20);
                addCurrency('coins', coinReward);
                
                // Random item rewards for good performance
                if (gameState.player.streak >= 5 && Math.random() < 0.1) {
                    awardRandomItem();
                }
                
                // AWS Credits for perfect streaks
                if (gameState.player.streak >= 10) {
                    addCurrency('awsCredits', 1);
                }
                
                // Damage enemy
                let damage = 20;
                if (gameState.combo >= 10) damage += 10; // Combo damage bonus
                
                gameState.enemy.hp -= damage;
                addEffect(gameState.enemy.x, gameState.enemy.y - 80, `-${damage}`, '#ff0044', 24);
                
                // Show damage animation
                showDamageNumber(damage, gameState.enemy.x, gameState.enemy.y - 30);
                
                // Play attack sound
                playSound('attack');
            } else {
                // Play incorrect sound
                playSound('incorrect');
                
                // Apply damage with shield consideration
                let damageToPlayer = 20;
                if (gameState.specialAbilities.shield.active) {
                    damageToPlayer = Math.floor(damageToPlayer / 2);
                    addEffect(gameState.player.x, gameState.player.y, '🛡️', '#00ffcc', 24);
                    playSound('shield');
                } else {
                    playSound('damage');
                }
                
                gameState.player.hp -= damageToPlayer;
                gameState.player.streak = 0;
                addEffect(gameState.player.x, gameState.player.y - 60, `-${damageToPlayer} HP`, '#ff0044', 20);
            }
            
            gameState.player.totalQuestions++;
            gameState.currentLevelProgress.questionsAnswered++;
            gameState.player.accuracy = Math.round((gameState.player.correctAnswers / gameState.player.totalQuestions) * 100);
            
            // Adaptive difficulty adjustment
            if (gameState.player.totalQuestions % 5 === 0) {
                adaptDifficulty();
            }
            
            // Check for level up
            gameState.player.exp += isCorrect ? 25 : 5;
            if (gameState.player.exp >= gameState.player.expToNext) {
                levelUp();
                playSound('levelup');
                triggerSave(); // Save on level up
                
                // Award level up rewards
                addCurrency('coins', gameState.player.level * 10);
                if (gameState.player.level % 5 === 0) {
                    addCurrency('gems', 1);
                    awardRandomItem();
                }
            }
            
            // Update achievement progress tracking
            const questionCategory = gameState.currentQuestion.category;
            const responseTime = gameState.questionStartTime ? Date.now() - gameState.questionStartTime : null;
            updateProgressTracking(questionCategory, isCorrect, responseTime);
            
            // Check for new achievements
            const newAchievements = checkAchievements();
            
            // Update challenge progress
            updateChallenge(isCorrect);
            
            // Update cooldowns and abilities
            updateCooldowns();
            updateAbilityButtons();
            updateUI();
            
            // Save progress every 5 questions or when achievements are earned
            if (gameState.player.totalQuestions % 5 === 0 || newAchievements.length > 0) {
                triggerSave();
            }
            
            // Reset timer for speed battles
            if (gameState.battleType === 'speed') {
                gameState.timeLimit = 30;
                document.getElementById('timer-display').classList.remove('timer-warning');
            }
            
            // Check battle end conditions
            if (gameState.enemy.hp <= 0) {
                gameState.enemy.isAlive = false;
                gameState.currentStage = 'victory';
                playSound('victory');
                playMusic('victory');
                setTimeout(() => {
                    nextLevel();
                }, 2000);
            } else if (gameState.player.hp <= 0) {
                gameState.currentStage = 'defeat';
                playSound('defeat');
                setTimeout(() => {
                    restartGame();
                }, 2000);
            } else {
                // Check if level is complete
                const currentLevel = LEVELS[gameState.currentLevel - 1];
                if (currentLevel && gameState.currentLevelProgress.questionsAnswered >= currentLevel.requiredQuestions) {
                    // Level completed, advance to next level
                    gameState.enemy.isAlive = false;
                    gameState.currentStage = 'victory';
                    addEffect(400, 300, 'Level Complete!', '#00ff00', 24);
                    setTimeout(() => {
                        nextLevel();
                    }, 2000);
                } else {
                    // Show brief feedback and auto-advance to next question
                    if (isCorrect) {
                        if (gameState.combo >= 5) {
                            addNotification(`Excellent! ${gameState.combo} in a row!`, 'success');
                        } else {
                            addNotification('Correct! Well done!', 'success');
                        }
                        // Advance faster for correct answers
                        setTimeout(() => {
                            nextBattle();
                        }, 1500);
                    } else {
                        // For incorrect answers: show explanation briefly, then auto-advance
                        const encouragements = [
                            'Keep learning! You\'re improving!',
                            'Not quite right. Try again!',
                            'Almost there! Keep studying!',
                            'Good effort! Learning takes time!'
                        ];
                        const randomEncouragement = encouragements[Math.floor(Math.random() * encouragements.length)];
                        addNotification(randomEncouragement, 'error');
                        
                        // Show explanation if available
                        if (gameState.currentQuestion.explanation) {
                            setTimeout(() => {
                                addNotification(`💡 ${gameState.currentQuestion.explanation}`, 'info');
                            }, 500);
                        }
                        
                        // Auto-advance after showing incorrect answer for 2 seconds
                        setTimeout(() => {
                            nextBattle();
                        }, 2500);
                    }
                }
            }
        }

        function performAttack() {
            // Add visual attack effect
            addEffect(gameState.enemy.x, gameState.enemy.y, '💥', '#ffcc00', 32);
            
            // Screen shake effect (simple)
            const canvas = gameState.canvas;
            canvas.style.transform = 'translate(2px, 2px)';
            setTimeout(() => {
                canvas.style.transform = 'translate(-2px, -2px)';
                setTimeout(() => {
                    canvas.style.transform = 'translate(0px, 0px)';
                }, 50);
            }, 50);
        }

        function levelUp() {
            gameState.player.level++;
            gameState.player.exp = 0;
            gameState.player.expToNext += 50;
            gameState.player.maxHp += 20;
            gameState.player.hp = gameState.player.maxHp;
            gameState.player.maxMp += 10;
            gameState.player.mp = gameState.player.maxMp;
            
            addEffect(gameState.player.x, gameState.player.y - 80, 'LEVEL UP!', '#00ff00', 28);
            addNotification(`Level ${gameState.player.level} reached!`, 'success');
            
            // Play level up sound
            playSound('levelup');
            
            // Show level up animation
            showLevelUpAnimation(gameState.player.level);
            
            // Check for level-based achievements
            checkAchievements();
        }

        function nextBattle() {
            gameState.player.wins++;
            
            // FORZAR reset completo de la UI
            const attackBtn = document.getElementById('attack-btn');
            const nextBattleBtn = document.getElementById('next-battle-btn');
            
            if (attackBtn) {
                attackBtn.style.display = 'inline-block';
                attackBtn.disabled = true;
                attackBtn.classList.add('loading');
            }
            
            if (nextBattleBtn) {
                nextBattleBtn.style.display = 'none';
            }
            
            // INMEDIATAMENTE limpiar todas las opciones sin animaciones para evitar trabas
            document.querySelectorAll('.pixel-option').forEach((option) => {
                option.classList.remove('selected', 'correct', 'incorrect');
                option.disabled = false;
                option.style.animation = '';
                option.style.backgroundColor = '';
                option.style.border = '';
            });
            
            // Reset COMPLETO del game state
            gameState.selectedAnswer = null;
            gameState.currentQuestion = null;
            
            // Update cooldowns and abilities
            updateCooldowns();
            updateAbilityButtons();
            
            // GARANTIZAR que siempre se carga una nueva pregunta
            console.log('🔄 Cargando nueva pregunta...');
            
            setTimeout(() => {
                if (attackBtn) {
                    attackBtn.classList.remove('loading');
                }
                
                // Forzar la carga de nueva pregunta
                loadQuestion().then(() => {
                    console.log('✅ Nueva pregunta cargada');
                }).catch((error) => {
                    console.error('❌ Error cargando pregunta:', error);
                    // Fallback: cargar pregunta local si falla
                    const questionData = getRandomAWSQuestion();
                    gameState.currentQuestion = questionData;
                    updateQuestionUI(questionData);
                });
            }, 300); // Reducido para respuesta más rápida
        }
        
        function forceReset() {
            // Función de emergencia para resetear completamente el estado
            console.log('🔄 Forcing complete reset...');
            
            gameState.selectedAnswer = null;
            gameState.currentQuestion = null;
            
            // Reset UI
            const attackBtn = document.getElementById('attack-btn');
            const nextBattleBtn = document.getElementById('next-battle-btn');
            
            if (attackBtn) {
                attackBtn.style.display = 'inline-block';
                attackBtn.disabled = true;
                attackBtn.classList.remove('loading');
            }
            
            if (nextBattleBtn) {
                nextBattleBtn.style.display = 'none';
            }
            
            // Reset all options
            document.querySelectorAll('.pixel-option').forEach((option) => {
                option.classList.remove('selected', 'correct', 'incorrect');
                option.disabled = false;
                option.style.backgroundColor = '';
                option.style.border = '';
            });
            
            // Force new question load
            loadQuestion();
        }
        
        function enableQuestionInteraction() {
            // Asegurar que la interacción esté disponible
            const attackBtn = document.getElementById('attack-btn');
            if (attackBtn) {
                attackBtn.disabled = true; // Mantener disabled hasta que se seleccione una opción
            }
            
            // Asegurar que las opciones estén clickeables
            document.querySelectorAll('.pixel-option').forEach((option, index) => {
                option.disabled = false;
                option.onclick = () => selectOption(index);
            });
            
            console.log('✅ Question interaction enabled');
        }

        function nextLevel() {
            gameState.currentLevel++;
            
            // Reset level progress for new level
            gameState.currentLevelProgress.questionsAnswered = 0;
            
            // Add level to completed levels
            if (!gameState.player.levelsCompleted.includes(gameState.currentLevel - 1)) {
                gameState.player.levelsCompleted.push(gameState.currentLevel - 1);
            }
            
            if (gameState.currentLevel > LEVELS.length) {
                // Game completed!
                triggerSave(); // Save final progress
                alert('🎉 Congratulations! You have mastered AWS Quest!');
                restartGame();
                return;
            }
            
            // Reset for next level
            gameState.enemy.hp = 50 + (gameState.currentLevel * 25);
            gameState.enemy.maxHp = gameState.enemy.hp;
            gameState.enemy.isAlive = true;
            gameState.currentStage = 'battle';
            
            addEffect(400, 200, `LEVEL ${gameState.currentLevel}`, '#00ffcc', 36);
            
            // Save on level completion
            triggerSave();
            
            loadQuestion();
        }

        function restartGame() {
            // Reset game state
            gameState.currentLevel = 1;
            gameState.currentStage = 'welcome';
            gameState.player.level = 1;
            gameState.player.hp = 100;
            gameState.player.maxHp = 100;
            gameState.player.mp = 50;
            gameState.player.maxMp = 50;
            gameState.player.exp = 0;
            gameState.player.expToNext = 100;
            gameState.player.score = 0;
            gameState.player.wins = 0;
            gameState.player.streak = 0;
            gameState.player.totalQuestions = 0;
            gameState.player.correctAnswers = 0;
            gameState.player.accuracy = 0;
            
            gameState.enemy.hp = 50;
            gameState.enemy.maxHp = 50;
            gameState.enemy.isAlive = true;
            
            // Show welcome screen
            document.getElementById('welcome-screen').classList.remove('hidden');
            document.getElementById('pixel-hud').style.display = 'none';
            document.getElementById('battle-screen').classList.remove('active');
        }

        function updateUI() {
            // Update HUD with smooth animations
            const hpPercent = (gameState.player.hp / gameState.player.maxHp) * 100;
            const mpPercent = (gameState.player.mp / gameState.player.maxMp) * 100;
            const expPercent = (gameState.player.exp / gameState.player.expToNext) * 100;
            
            // Animate bars
            animateBar('hp-bar', hpPercent);
            animateBar('mp-bar', mpPercent);
            animateBar('exp-bar', expPercent);
            
            // Update text with count-up animation
            updateCounterText('hp-text', gameState.player.hp);
            updateCounterText('mp-text', gameState.player.mp);
            updateCounterText('exp-text', gameState.player.exp);
            updateCounterText('character-level', gameState.player.level);
            updateCounterText('character-score', gameState.player.score);
            
            // Update level progress with visual feedback
            const currentLevel = LEVELS[gameState.currentLevel - 1];
            if (currentLevel) {
                gameState.currentLevelProgress.questionsRequired = currentLevel.requiredQuestions || 5;
                const progressElement = document.getElementById('level-progress');
                const progressText = `${gameState.currentLevelProgress.questionsAnswered}/${gameState.currentLevelProgress.questionsRequired}`;
                
                if (progressElement.textContent !== progressText) {
                    progressElement.textContent = progressText;
                    progressElement.style.animation = 'pulse 0.5s ease-in-out';
                    setTimeout(() => {
                        progressElement.style.animation = '';
                    }, 500);
                }
            }
            
            // Update accuracy display
            const accuracyElement = document.getElementById('accuracy-display');
            if (accuracyElement) {
                accuracyElement.textContent = `${gameState.player.accuracy}%`;
            }
        }
        
        function animateBar(barId, targetPercent) {
            const bar = document.getElementById(barId);
            const currentPercent = parseFloat(bar.style.width) || 0;
            
            if (Math.abs(currentPercent - targetPercent) > 0.1) {
                const step = (targetPercent - currentPercent) / 10;
                let current = currentPercent;
                
                const animate = () => {
                    current += step;
                    if ((step > 0 && current < targetPercent) || (step < 0 && current > targetPercent)) {
                        bar.style.width = current + '%';
                        requestAnimationFrame(animate);
                    } else {
                        bar.style.width = targetPercent + '%';
                    }
                };
                
                requestAnimationFrame(animate);
            }
        }
        
        function updateCounterText(elementId, targetValue) {
            const element = document.getElementById(elementId);
            const currentValue = parseInt(element.textContent) || 0;
            
            if (currentValue !== targetValue) {
                const step = targetValue > currentValue ? 1 : -1;
                let current = currentValue;
                
                const animate = () => {
                    current += step;
                    element.textContent = current;
                    
                    if (current !== targetValue) {
                        setTimeout(animate, 30);
                    }
                };
                
                animate();
            }
        }

        // Enhanced AWS Questions Database by Level
        const QUESTIONS_BY_LEVEL = {
            1: [ // AWS Basics
                {
                    question: "What AWS service provides scalable compute capacity in the cloud?",
                    options: ["Amazon S3", "Amazon EC2", "Amazon RDS", "Amazon VPC"],
                    correct: 1,
                    explanation: "Amazon EC2 provides resizable compute capacity in the cloud."
                },
                {
                    question: "Which AWS service is used for object storage?",
                    options: ["Amazon S3", "Amazon EBS", "Amazon EFS", "Amazon Glacier"],
                    correct: 0,
                    explanation: "Amazon S3 is a web service for storing and retrieving any amount of data."
                },
                {
                    question: "What does AWS Lambda allow you to do?",
                    options: ["Store files", "Run code without provisioning servers", "Create databases", "Monitor applications"],
                    correct: 1,
                    explanation: "AWS Lambda runs your code without provisioning or managing servers."
                },
                {
                    question: "Which service provides DNS services for AWS?",
                    options: ["Amazon CloudFront", "Amazon Route 53", "Amazon VPC", "Amazon API Gateway"],
                    correct: 1,
                    explanation: "Amazon Route 53 is a highly available and scalable DNS web service."
                }
            ],
            2: [ // EC2 Mastery
                {
                    question: "Which instance type is best for CPU-intensive applications?",
                    options: ["t3.micro", "c5.large", "m5.large", "r5.large"],
                    correct: 1,
                    explanation: "C5 instances are optimized for compute-intensive applications."
                },
                {
                    question: "What is the maximum number of security groups per EC2 instance?",
                    options: ["3", "5", "10", "Unlimited"],
                    correct: 1,
                    explanation: "You can assign up to 5 security groups to an EC2 instance."
                },
                {
                    question: "Which storage type provides the highest IOPS for EC2?",
                    options: ["gp2", "gp3", "io1", "st1"],
                    correct: 2,
                    explanation: "io1 volumes can deliver up to 64,000 IOPS per volume."
                },
                {
                    question: "What happens to instance store data when an EC2 instance is stopped?",
                    options: ["Data is preserved", "Data is lost", "Data is moved to S3", "Data is encrypted"],
                    correct: 1,
                    explanation: "Instance store data is ephemeral and lost when the instance is stopped."
                }
            ],
            3: [ // Storage Solutions
                {
                    question: "What is the maximum size of a single S3 object?",
                    options: ["5 TB", "5 GB", "100 GB", "1 TB"],
                    correct: 0,
                    explanation: "A single S3 object can be up to 5 TB in size."
                },
                {
                    question: "Which S3 storage class is designed for long-term archival?",
                    options: ["Standard", "Standard-IA", "Glacier", "Reduced Redundancy"],
                    correct: 2,
                    explanation: "Amazon S3 Glacier is designed for long-term archival and backup."
                },
                {
                    question: "What is the minimum storage duration for S3 Glacier?",
                    options: ["1 day", "30 days", "90 days", "180 days"],
                    correct: 2,
                    explanation: "S3 Glacier has a minimum storage duration of 90 days."
                },
                {
                    question: "Which EBS volume type is best for throughput-intensive applications?",
                    options: ["gp2", "gp3", "io1", "st1"],
                    correct: 3,
                    explanation: "st1 (Throughput Optimized HDD) is designed for throughput-intensive workloads."
                }
            ]
        };

        function getRandomAWSQuestion() {
            const levelQuestions = QUESTIONS_BY_LEVEL[gameState.currentLevel] || QUESTIONS_BY_LEVEL[1];
            return levelQuestions[Math.floor(Math.random() * levelQuestions.length)];
        }

        // Level Management Functions
        function showLevelSelection() {
            document.getElementById('welcome-screen').classList.add('hidden');
            document.getElementById('level-selection-screen').classList.add('active');
            populateLevelGrid();
        }

        function populateLevelGrid() {
            const levelGrid = document.getElementById('level-grid');
            levelGrid.innerHTML = '';

            LEVELS.forEach((level, index) => {
                const levelCard = document.createElement('div');
                levelCard.className = 'level-card';
                
                // Check if level is unlocked
                const isUnlocked = index === 0 || gameState.player.level >= index;
                if (!isUnlocked) {
                    levelCard.classList.add('locked');
                }

                levelCard.innerHTML = `
                    <div class="level-title">LEVEL ${level.id}: ${level.name}</div>
                    <div class="level-description">${level.description}</div>
                    <div class="level-stats">
                        Difficulty: ${level.questionDifficulty.toUpperCase()}<br>
                        Enemies: ${level.enemies.length}
                    </div>
                `;

                if (isUnlocked) {
                    levelCard.addEventListener('click', () => selectLevel(level.id));
                }

                levelGrid.appendChild(levelCard);
            });
        }

        function selectLevel(levelId) {
            gameState.currentLevel = levelId;
            const level = LEVELS[levelId - 1];
            
            // Reset level progress
            gameState.currentLevelProgress.questionsAnswered = 0;
            gameState.currentLevelProgress.questionsRequired = level.requiredQuestions || 5;
            
            // Update background and enemy based on level
            gameState.background = level.background;
            gameState.enemy.name = `Level ${levelId} Boss`;
            gameState.enemy.hp = 50 + (levelId * 25);
            gameState.enemy.maxHp = gameState.enemy.hp;
            
            // Hide level selection and start battle
            document.getElementById('level-selection-screen').classList.remove('active');
            startBattle();
        }

        function backToMenu() {
            document.getElementById('level-selection-screen').classList.remove('active');
            document.getElementById('welcome-screen').classList.remove('hidden');
        }

        // Advanced Battle System
        function initializeBattleType(type = 'normal') {
            gameState.battleType = type;
            
            switch(type) {
                case 'speed':
                    gameState.timeLimit = 30; // 30 seconds per question
                    document.getElementById('timer-display').classList.add('active');
                    startTimer();
                    break;
                case 'boss':
                    gameState.enemy.hp *= 2; // Double HP for boss
                    gameState.enemy.maxHp = gameState.enemy.hp;
                    break;
                case 'endurance':
                    // Continuous questions until defeat
                    break;
            }
            
            // Update battle type indicator
            const indicator = document.getElementById('battle-type-indicator');
            const text = document.getElementById('battle-type-text');
            indicator.classList.add('active');
            indicator.className = `battle-type-indicator active battle-type-${type}`;
            text.textContent = `${type.toUpperCase()} BATTLE`;
        }

        function startTimer() {
            if (gameState.timeLimit === null) return;
            
            const timerElement = document.getElementById('timer-value');
            const timerDisplay = document.getElementById('timer-display');
            
            const countdown = setInterval(() => {
                gameState.timeLimit--;
                timerElement.textContent = gameState.timeLimit;
                
                if (gameState.timeLimit <= 10) {
                    timerDisplay.classList.add('timer-warning');
                }
                
                if (gameState.timeLimit <= 0) {
                    clearInterval(countdown);
                    // Auto-submit wrong answer on timeout
                    gameState.selectedAnswer = -1; // Invalid answer
                    attack();
                }
            }, 1000);
        }

        // Special Abilities System
        function useAbility(abilityName) {
            const ability = gameState.specialAbilities[abilityName];
            
            if (ability.cooldown > 0 || gameState.player.mp < ability.cost) {
                addEffect(gameState.player.x, gameState.player.y - 40, 'NOT READY', '#ff0044', 16);
                return;
            }
            
            // Consume MP
            gameState.player.mp -= ability.cost;
            ability.cooldown = 3; // 3 question cooldown
            
            switch(abilityName) {
                case 'fireball':
                    // Deal extra damage to enemy
                    gameState.enemy.hp -= 30;
                    addEffect(gameState.enemy.x, gameState.enemy.y, '🔥', '#ff8800', 32);
                    addEffect(gameState.enemy.x, gameState.enemy.y - 60, '-30', '#ff0044', 24);
                    break;
                    
                case 'heal':
                    // Restore HP
                    const healAmount = 40;
                    gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healAmount);
                    addEffect(gameState.player.x, gameState.player.y, '💚', '#00ff00', 32);
                    addEffect(gameState.player.x, gameState.player.y - 60, `+${healAmount}`, '#00ff00', 20);
                    break;
                    
                case 'shield':
                    // Activate shield for next few attacks
                    ability.active = true;
                    gameState.player.shieldTurns = 3;
                    addEffect(gameState.player.x, gameState.player.y, '🛡️', '#00ffcc', 32);
                    break;
            }
            
            updateAbilityButtons();
            updateUI();
        }

        function updateAbilityButtons() {
            Object.keys(gameState.specialAbilities).forEach(abilityName => {
                const ability = gameState.specialAbilities[abilityName];
                const button = document.getElementById(`${abilityName}-btn`);
                
                if (ability.cooldown > 0 || gameState.player.mp < ability.cost) {
                    button.classList.add('disabled');
                    button.disabled = true;
                } else {
                    button.classList.remove('disabled');
                    button.disabled = false;
                }
            });
        }

        // Combo System
        function updateCombo(isCorrect) {
            if (isCorrect) {
                gameState.combo++;
                gameState.maxCombo = Math.max(gameState.maxCombo, gameState.combo);
                
                // Combo bonuses
                if (gameState.combo >= 5) {
                    const bonus = gameState.combo * 10;
                    gameState.player.score += bonus;
                    addEffect(gameState.player.x, gameState.player.y - 40, `COMBO +${bonus}`, '#ffcc00', 18);
                }
                
                document.getElementById('combo-display').classList.add('active');
                document.getElementById('combo-number').textContent = gameState.combo;
            } else {
                gameState.combo = 0;
                document.getElementById('combo-display').classList.remove('active');
            }
        }

        // Enhanced Achievement System Functions
        function checkAchievements() {
            const stats = getPlayerStats();
            const newAchievements = [];
            
            Object.values(ACHIEVEMENTS).forEach(achievement => {
                // Skip if already earned
                if (gameState.player.achievements.includes(achievement.id)) {
                    return;
                }
                
                // Check if requirement is met
                if (achievement.requirement(stats)) {
                    newAchievements.push(achievement);
                    gameState.player.achievements.push(achievement.id);
                    
                    // Apply rewards
                    if (achievement.reward.exp) {
                        gameState.player.exp += achievement.reward.exp;
                        addEffect(gameState.player.x, gameState.player.y - 100, `+${achievement.reward.exp} EXP`, '#00ff00', 16);
                    }
                    
                    if (achievement.reward.title) {
                        gameState.player.title = achievement.reward.title;
                    }
                    
                    if (achievement.reward.ability) {
                        gameState.player.unlockedFeatures.push(achievement.reward.ability);
                    }
                    
                    // Show achievement notification
                    showAchievementNotification(achievement);
                }
            });
            
            // Check for level up
            checkLevelUp();
            
            // Save progress if new achievements
            if (newAchievements.length > 0) {
                triggerSave();
            }
            
            return newAchievements;
        }
        
        function getPlayerStats() {
            const accuracy = gameState.player.totalQuestions > 0 ? 
                (gameState.player.correctAnswers / gameState.player.totalQuestions) * 100 : 0;
            
            return {
                ...gameState.player,
                ...gameState.progressStats,
                accuracy: accuracy,
                bestStreak: Math.max(gameState.maxCombo, gameState.player.longestStreak || 0),
                dailyStreak: gameState.player.dailyStreak || 0,
                questionsAnswered: gameState.player.totalQuestions,
                correctAnswers: gameState.player.correctAnswers,
                maxCombo: gameState.maxCombo,
                levelsCompleted: gameState.player.levelsCompleted,
                perfectLevels: gameState.player.perfectRounds || 0,
                fastAnswers: gameState.player.fastAnswers || 0,
                lateNightSessions: gameState.player.lateNightSessions || 0,
                earlyMorningSessions: gameState.player.earlyMorningSessions || 0,
                categoryCorrect: gameState.player.categoryCorrect || {},
                domainMastery: gameState.player.domainMastery || 0
            };
        }
        
        function showAchievementNotification(achievement) {
            // Create special achievement notification
            const notification = document.createElement('div');
            notification.className = `achievement-notification ${achievement.rarity}`;
            notification.innerHTML = `
                <div class="achievement-header">
                    <span class="achievement-icon">${achievement.icon}</span>
                    <span class="achievement-title">Achievement Unlocked!</span>
                </div>
                <div class="achievement-name">${achievement.name}</div>
                <div class="achievement-description">${achievement.description}</div>
                <div class="achievement-rarity">${achievement.rarity.toUpperCase()}</div>
            `;
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.classList.add('show');
            }, 100);
            
            // Show achievement animation
            showAchievementAnimation(achievement);
            
            // Remove after 5 seconds
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 500);
            }, 5000);
            
            // Play achievement sound effect
            if (achievement.rarity === 'legendary') {
                playSound('perfect');
            } else {
                playSound('achievement');
            }
            
            addEffect(400, 300, 'ACHIEVEMENT!', '#ffcc00', 24);
        }
        
        function updateProgressTracking(questionCategory, isCorrect, responseTime) {
            const now = new Date();
            const hour = now.getHours();
            
            // Update category tracking
            if (!gameState.player.categoryCorrect) {
                gameState.player.categoryCorrect = {};
            }
            
            const categoryKey = questionCategory?.toLowerCase() || 'general';
            if (!gameState.player.categoryCorrect[categoryKey]) {
                gameState.player.categoryCorrect[categoryKey] = 0;
            }
            
            if (isCorrect) {
                gameState.player.categoryCorrect[categoryKey]++;
            }
            
            // Update time-based achievements
            if (hour >= 22 || hour <= 2) {
                gameState.player.lateNightSessions = (gameState.player.lateNightSessions || 0) + 1;
            }
            
            if (hour >= 5 && hour <= 7) {
                gameState.player.earlyMorningSessions = (gameState.player.earlyMorningSessions || 0) + 1;
            }
            
            // Update fast answer tracking
            if (responseTime && responseTime < 5000) { // Under 5 seconds
                gameState.player.fastAnswers = (gameState.player.fastAnswers || 0) + 1;
            }
            
            // Update daily streak
            updateDailyStreak();
            
            // Update study time
            gameState.player.studyTime = (gameState.player.studyTime || 0) + (responseTime || 0);
        }
        
        function updateDailyStreak() {
            const today = new Date().toDateString();
            const lastPlayDate = gameState.player.lastPlayDate;
            
            if (lastPlayDate) {
                const lastDate = new Date(lastPlayDate);
                const todayDate = new Date(today);
                const daysDiff = Math.floor((todayDate - lastDate) / (1000 * 60 * 60 * 24));
                
                if (daysDiff === 1) {
                    // Consecutive day
                    gameState.player.dailyStreak = (gameState.player.dailyStreak || 0) + 1;
                } else if (daysDiff > 1) {
                    // Streak broken
                    gameState.player.dailyStreak = 1;
                }
                // Same day, no change
            } else {
                // First time playing
                gameState.player.dailyStreak = 1;
            }
            
            gameState.player.lastPlayDate = today;
        }
        
        function showProgressPanel() {
            const panel = document.getElementById('progress-panel');
            if (panel) {
                panel.classList.toggle('active');
                updateProgressDisplay();
            }
        }
        
        function updateProgressDisplay() {
            const stats = getPlayerStats();
            const progressContainer = document.getElementById('progress-content');
            
            if (!progressContainer) return;
            
            const achievementCount = gameState.player.achievements.length;
            const totalAchievements = Object.keys(ACHIEVEMENTS).length;
            
            progressContainer.innerHTML = `
                <div class="progress-section">
                    <h3>🏆 Achievements</h3>
                    <div class="progress-bar-container">
                        <div class="progress-bar" style="width: ${(achievementCount / totalAchievements) * 100}%"></div>
                    </div>
                    <span>${achievementCount}/${totalAchievements} Unlocked</span>
                </div>
                
                <div class="progress-section">
                    <h3>📊 Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <span class="stat-label">Questions Answered</span>
                            <span class="stat-value">${stats.questionsAnswered}</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Accuracy</span>
                            <span class="stat-value">${stats.accuracy.toFixed(1)}%</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Best Streak</span>
                            <span class="stat-value">${stats.bestStreak}</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Daily Streak</span>
                            <span class="stat-value">${stats.dailyStreak} days</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Levels Completed</span>
                            <span class="stat-value">${stats.levelsCompleted.length}/12</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Study Time</span>
                            <span class="stat-value">${Math.round((stats.studyTime || 0) / 60000)} min</span>
                        </div>
                    </div>
                </div>
                
                <div class="progress-section">
                    <h3>🎯 Recent Achievements</h3>
                    <div class="recent-achievements">
                        ${gameState.player.achievements.slice(-5).map(id => {
                            const achievement = ACHIEVEMENTS[id];
                            return achievement ? `
                                <div class="achievement-item ${achievement.rarity}">
                                    <span class="achievement-icon">${achievement.icon}</span>
                                    <div class="achievement-info">
                                        <div class="achievement-name">${achievement.name}</div>
                                        <div class="achievement-desc">${achievement.description}</div>
                                    </div>
                                </div>
                            ` : '';
                        }).join('')}
                    </div>
                </div>
            `;
        }
        
        function checkLevelUp() {
            while (gameState.player.exp >= gameState.player.expToNext) {
                gameState.player.exp -= gameState.player.expToNext;
                gameState.player.level++;
                gameState.player.expToNext += 50;
                gameState.player.maxHp += 20;
                gameState.player.hp = gameState.player.maxHp;
                gameState.player.maxMp += 10;
                gameState.player.mp = gameState.player.maxMp;
                
                addEffect(gameState.player.x, gameState.player.y - 80, 'LEVEL UP!', '#00ff00', 28);
                addNotification(`Level ${gameState.player.level} reached!`, 'success');
            }
        }
        
        // Initialize progress tracking on game start
        function initializeProgressTracking() {
            // Set up progress tracking
            if (!gameState.player.categoryCorrect) {
                gameState.player.categoryCorrect = {};
            }
            
            if (!gameState.player.progressStats) {
                gameState.player.progressStats = {
                    totalPlayTime: 0,
                    questionsAnswered: 0,
                    correctAnswers: 0,
                    categoriesPlayed: new Set(),
                    levelsCompleted: [],
                    averageResponseTime: 0,
                    bestStreak: 0,
                    perfectGames: 0,
                    studySessions: 0
                };
            }
            
            // Initialize session tracking
            gameState.sessionStartTime = Date.now();
            gameState.player.progressStats.studySessions++;
            
            // Update daily streak
            updateDailyStreak();
        }
        
        // Enhanced save function with achievement data
        // Enhanced Save System with Error Handling
        async function saveGame() {
            if (!gameState.isAuthenticated) {
                // Save locally for non-authenticated users
                saveLocalProgress();
                addNotification('Game saved locally!', 'success');
                return;
            }
            
            try {
                await saveGameProgress();
                addNotification('Game saved successfully!', 'success');
                playSound('notification');
            } catch (error) {
                console.error('Save failed:', error);
                // Fallback to local save
                saveLocalProgress();
                addNotification('Saved locally (server unavailable)', 'warning');
            }
        }
        
        function saveLocalProgress() {
            const progressData = {
                level: gameState.player.level,
                experience: gameState.player.exp,
                totalScore: gameState.player.score,
                maxCombo: gameState.maxCombo,
                gamesPlayed: gameState.player.gamesPlayed,
                totalQuestions: gameState.player.totalQuestions,
                correctAnswers: gameState.player.correctAnswers,
                levelsCompleted: gameState.player.levelsCompleted,
                achievements: gameState.player.achievements,
                specialAbilities: gameState.specialAbilities,
                inventory: gameState.inventory,
                settings: gameState.player.settings,
                currentLevel: gameState.currentLevel,
                currentLevelProgress: gameState.currentLevelProgress,
                // Achievement-related data
                achievementProgress: gameState.player.achievementProgress || {},
                dailyStreak: gameState.player.dailyStreak || 0,
                lastPlayDate: gameState.player.lastPlayDate,
                studyTime: gameState.player.studyTime || 0,
                categoryCorrect: gameState.player.categoryCorrect || {},
                fastAnswers: gameState.player.fastAnswers || 0,
                lateNightSessions: gameState.player.lateNightSessions || 0,
                earlyMorningSessions: gameState.player.earlyMorningSessions || 0,
                perfectRounds: gameState.player.perfectRounds || 0,
                longestStreak: gameState.player.longestStreak || 0,
                progressStats: gameState.player.progressStats || {},
                lastSave: Date.now()
            };
            
            localStorage.setItem('awsQuestProgress', JSON.stringify(progressData));
            console.log('✅ Progress saved locally');
        }
        
        function loadLocalProgress() {
            try {
                const savedProgress = localStorage.getItem('awsQuestProgress');
                if (savedProgress) {
                    const progressData = JSON.parse(savedProgress);
                    loadGameProgress(progressData);
                    console.log('✅ Local progress loaded');
                    return true;
                }
            } catch (error) {
                console.error('Error loading local progress:', error);
            }
            return false;
        }
        
        function returnToMainMenu() {
            // Save before returning to menu
            saveGame();
            
            // Stop current music
            stopMusic();
            
            // Reset game state
            gameState.currentStage = 'welcome';
            gameState.isInBattle = false;
            
            // Hide game elements
            document.getElementById('pixel-hud').style.display = 'none';
            document.getElementById('battle-screen').classList.remove('active');
            document.getElementById('level-indicator').style.display = 'none';
            document.getElementById('abilities-panel').classList.remove('active');
            
            // Show welcome screen
            document.getElementById('welcome-screen').classList.remove('hidden');
            
            // Return to menu music
            playMusic('menu');
            
            addNotification('Returned to main menu', 'info');
            playSound('click');
        }
        
        function saveProgressWithAchievements() {
            const progressData = {
                level: gameState.player.level,
                experience: gameState.player.exp,
                totalScore: gameState.player.score,
                maxCombo: gameState.maxCombo,
                gamesPlayed: gameState.player.gamesPlayed,
                totalQuestions: gameState.player.totalQuestions,
                correctAnswers: gameState.player.correctAnswers,
                levelsCompleted: gameState.player.levelsCompleted,
                achievements: gameState.player.achievements,
                specialAbilities: gameState.specialAbilities,
                inventory: gameState.inventory,
                settings: gameState.player.settings,
                // New achievement-related data
                achievementProgress: gameState.player.achievementProgress || {},
                dailyStreak: gameState.player.dailyStreak || 0,
                lastPlayDate: gameState.player.lastPlayDate,
                studyTime: gameState.player.studyTime || 0,
                categoryCorrect: gameState.player.categoryCorrect || {},
                fastAnswers: gameState.player.fastAnswers || 0,
                lateNightSessions: gameState.player.lateNightSessions || 0,
                earlyMorningSessions: gameState.player.earlyMorningSessions || 0,
                perfectRounds: gameState.player.perfectRounds || 0,
                longestStreak: gameState.player.longestStreak || 0,
                progressStats: gameState.player.progressStats || {}
            };
            
            return progressData;
        }
        
        // Special Challenges and Mini-Games System
        function initializeChallengeSystem() {
            // Initialize available challenges based on player level
            updateAvailableChallenges();
            
            // Set up daily challenges
            generateDailyChanges();
            
            // Initialize mini-game scores
            if (!gameState.player.miniGameScores) {
                gameState.player.miniGameScores = {};
            }
        }
        
        function updateAvailableChallenges() {
            challengeState.availableChallenges = [];
            
            Object.values(SPECIAL_CHALLENGES).forEach(challenge => {
                if (meetsChallengeRequirements(challenge)) {
                    challengeState.availableChallenges.push(challenge);
                }
            });
        }
        
        function meetsChallengeRequirements(challenge) {
            const req = challenge.requirements;
            const player = gameState.player;
            
            if (req.level && player.level < req.level) return false;
            if (req.accuracy && player.accuracy < req.accuracy) return false;
            if (req.streak && gameState.maxCombo < req.streak) return false;
            if (req.hp && player.hp < req.hp) return false;
            if (req.wins && player.wins < req.wins) return false;
            
            return true;
        }
        
        function startChallenge(challengeId) {
            const challenge = SPECIAL_CHALLENGES[challengeId];
            if (!challenge || !meetsChallengeRequirements(challenge)) {
                addNotification('Challenge requirements not met!', 'error');
                return;
            }
            
            challengeState.isActive = true;
            challengeState.currentChallenge = challenge;
            challengeState.startTime = Date.now();
            challengeState.progress = 0;
            
            // Set up challenge-specific state
            switch(challenge.type) {
                case 'speed':
                    gameState.challengeTimeLimit = challenge.timeLimit;
                    gameState.challengeQuestionsRemaining = challenge.questionCount;
                    break;
                case 'accuracy':
                    gameState.challengeStreakTarget = challenge.streakRequired;
                    gameState.challengeCurrentStreak = 0;
                    break;
                case 'specialization':
                    gameState.challengeCategory = selectRandomCategory();
                    gameState.challengeQuestionsRemaining = challenge.questionCount;
                    break;
                case 'endurance':
                    gameState.challengeInitialHp = gameState.player.hp;
                    gameState.challengeMaxHpLoss = challenge.maxHpLoss;
                    gameState.challengeQuestionsRemaining = challenge.questionCount;
                    break;
            }
            
            // Show challenge start notification
            addNotification(`Challenge Started: ${challenge.name}`, 'info');
            showChallengeHUD();
        }
        
        function updateChallenge(isCorrect) {
            if (!challengeState.isActive) return;
            
            const challenge = challengeState.currentChallenge;
            
            switch(challenge.type) {
                case 'speed':
                    gameState.challengeQuestionsRemaining--;
                    if (gameState.challengeQuestionsRemaining <= 0) {
                        completeChallenge(true);
                    } else if (gameState.challengeTimeLimit <= 0) {
                        completeChallenge(false);
                    }
                    break;
                    
                case 'accuracy':
                    if (isCorrect) {
                        gameState.challengeCurrentStreak++;
                        if (gameState.challengeCurrentStreak >= gameState.challengeStreakTarget) {
                            completeChallenge(true);
                        }
                    } else {
                        completeChallenge(false);
                    }
                    break;
                    
                case 'specialization':
                    if (gameState.currentQuestion.category === gameState.challengeCategory) {
                        gameState.challengeQuestionsRemaining--;
                        if (gameState.challengeQuestionsRemaining <= 0) {
                            completeChallenge(true);
                        }
                    }
                    break;
                    
                case 'endurance':
                    gameState.challengeQuestionsRemaining--;
                    const hpLoss = (gameState.challengeInitialHp - gameState.player.hp) / gameState.challengeInitialHp;
                    if (hpLoss > gameState.challengeMaxHpLoss) {
                        completeChallenge(false);
                    } else if (gameState.challengeQuestionsRemaining <= 0) {
                        completeChallenge(true);
                    }
                    break;
            }
            
            updateChallengeHUD();
        }
        
        function completeChallenge(success) {
            const challenge = challengeState.currentChallenge;
            
            challengeState.isActive = false;
            hideChallengeHUD();
            
            if (success) {
                // Apply rewards
                if (challenge.reward.exp) {
                    gameState.player.exp += challenge.reward.exp;
                    addEffect(400, 300, `+${challenge.reward.exp} EXP`, '#00ff00', 20);
                }
                
                if (challenge.reward.title) {
                    gameState.player.title = challenge.reward.title;
                }
                
                if (challenge.reward.ability) {
                    gameState.player.unlockedFeatures.push(challenge.reward.ability);
                }
                
                challengeState.completedChallenges.push(challenge.id);
                addNotification(`Challenge Completed: ${challenge.name}!`, 'success');
                
                // Check for achievements
                checkAchievements();
            } else {
                addNotification(`Challenge Failed: ${challenge.name}`, 'error');
            }
            
            // Reset challenge state
            challengeState.currentChallenge = null;
            challengeState.startTime = null;
            challengeState.progress = 0;
            
            // Save progress
            triggerSave();
        }
        
        function showChallengeHUD() {
            const challengeHUD = document.getElementById('challenge-hud');
            if (challengeHUD) {
                challengeHUD.style.display = 'block';
                challengeHUD.classList.add('active');
                updateChallengeHUD();
            }
        }
        
        function hideChallengeHUD() {
            const challengeHUD = document.getElementById('challenge-hud');
            if (challengeHUD) {
                challengeHUD.style.display = 'none';
                challengeHUD.classList.remove('active');
            }
        }
        
        function updateChallengeHUD() {
            if (!challengeState.isActive) return;
            
            const challenge = challengeState.currentChallenge;
            const progressText = document.getElementById('challenge-progress');
            const timerText = document.getElementById('challenge-timer');
            
            if (progressText) {
                switch(challenge.type) {
                    case 'speed':
                        progressText.textContent = `${challenge.questionCount - gameState.challengeQuestionsRemaining}/${challenge.questionCount}`;
                        break;
                    case 'accuracy':
                        progressText.textContent = `${gameState.challengeCurrentStreak}/${gameState.challengeStreakTarget}`;
                        break;
                    case 'specialization':
                        progressText.textContent = `${challenge.questionCount - gameState.challengeQuestionsRemaining}/${challenge.questionCount} (${gameState.challengeCategory})`;
                        break;
                    case 'endurance':
                        const hpLoss = Math.round(((gameState.challengeInitialHp - gameState.player.hp) / gameState.challengeInitialHp) * 100);
                        progressText.textContent = `${challenge.questionCount - gameState.challengeQuestionsRemaining}/${challenge.questionCount} (HP Loss: ${hpLoss}%)`;
                        break;
                }
            }
            
            if (timerText && challenge.timeLimit) {
                const elapsed = Math.floor((Date.now() - challengeState.startTime) / 1000);
                const remaining = Math.max(0, challenge.timeLimit - elapsed);
                timerText.textContent = `${remaining}s`;
                
                if (remaining <= 0 && challenge.type === 'speed') {
                    completeChallenge(false);
                }
            }
        }
        
        function startMiniGame(gameId) {
            const miniGame = MINI_GAMES[gameId];
            if (!miniGame) return;
            
            challengeState.miniGameActive = true;
            challengeState.miniGameData = {
                id: gameId,
                ...miniGame,
                startTime: Date.now(),
                score: 0,
                completed: false
            };
            
            // Initialize specific mini-game
            switch(miniGame.type) {
                case 'matching':
                    initializeServiceMatcher();
                    break;
                case 'construction':
                    initializeArchitectureBuilder();
                    break;
                case 'calculation':
                    initializeCostCalculator();
                    break;
                case 'analysis':
                    initializeSecurityAudit();
                    break;
                case 'arcade':
                    initializeSnakeGame();
                    break;
                case 'memory':
                    initializeMemoryCards();
                    break;
            }
            
            showMiniGameUI();
        }
        
        function completeMiniGame(score) {
            const miniGameData = challengeState.miniGameData;
            
            // Apply rewards
            if (miniGameData.reward.exp) {
                gameState.player.exp += miniGameData.reward.exp;
                addEffect(400, 300, `+${miniGameData.reward.exp} EXP`, '#00ff00', 16);
            }
            
            if (miniGameData.reward.coins) {
                gameState.player.coins = (gameState.player.coins || 0) + miniGameData.reward.coins;
                addEffect(400, 320, `+${miniGameData.reward.coins} Coins`, '#ffcc00', 16);
            }
            
            // Save high score
            const gameId = miniGameData.id;
            if (!gameState.player.miniGameScores[gameId] || score > gameState.player.miniGameScores[gameId]) {
                gameState.player.miniGameScores[gameId] = score;
                addNotification(`New High Score: ${score}!`, 'success');
            }
            
            challengeState.miniGameActive = false;
            hideMiniGameUI();
            
            // Check achievements
            checkAchievements();
            
            // Save progress
            triggerSave();
        }
        
        function generateDailyChanges() {
            const today = new Date().toDateString();
            const lastDailyReset = localStorage.getItem('lastDailyReset');
            
            if (lastDailyReset !== today) {
                // Generate new daily challenges
                challengeState.dailyChallenges = [];
                
                // Select 3 random challenges
                const availableChallenges = Object.values(SPECIAL_CHALLENGES).filter(c => meetsChallengeRequirements(c));
                for (let i = 0; i < 3 && i < availableChallenges.length; i++) {
                    const randomChallenge = availableChallenges[Math.floor(Math.random() * availableChallenges.length)];
                    challengeState.dailyChallenges.push({
                        ...randomChallenge,
                        reward: {
                            ...randomChallenge.reward,
                            exp: randomChallenge.reward.exp * 1.5 // Bonus for daily challenges
                        }
                    });
                }
                
                localStorage.setItem('lastDailyReset', today);
                addNotification('New daily challenges available!', 'info');
            }
        }
        
        function selectRandomCategory() {
            const categories = ['Compute', 'Storage', 'Database', 'Networking', 'Security', 'Analytics', 'Cost Optimization'];
            return categories[Math.floor(Math.random() * categories.length)];
        }
        
        // Reduce cooldowns after each question
        function updateCooldowns() {
            Object.values(gameState.specialAbilities).forEach(ability => {
                if (ability.cooldown > 0) {
                    ability.cooldown--;
                }
            });
            
            // Reduce shield turns
            if (gameState.player.shieldTurns > 0) {
                gameState.player.shieldTurns--;
                if (gameState.player.shieldTurns <= 0) {
                    gameState.specialAbilities.shield.active = false;
                }
            }
            
            // Update challenge progress
            if (challengeState.isActive) {
                updateChallengeHUD();
            }
        }
        
        // Mini-Game Implementations
        function initializeServiceMatcher() {
            const services = [
                { name: 'EC2', description: 'Virtual servers in the cloud', icon: '💻' },
                { name: 'S3', description: 'Object storage service', icon: '💾' },
                { name: 'RDS', description: 'Managed relational database', icon: '🗃️' },
                { name: 'Lambda', description: 'Serverless compute service', icon: '⚡' },
                { name: 'VPC', description: 'Virtual private cloud', icon: '🌐' },
                { name: 'CloudFront', description: 'Content delivery network', icon: '🚀' }
            ];
            
            challengeState.miniGameData.services = services.slice(0, challengeState.miniGameData.pairs);
            challengeState.miniGameData.matched = [];
            challengeState.miniGameData.selected = null;
            challengeState.miniGameData.attempts = 0;
            
            displayServiceMatcher();
        }
        
        function displayServiceMatcher() {
            const container = document.getElementById('mini-game-content');
            if (!container) return;
            
            const gameData = challengeState.miniGameData;
            let html = '<div class="service-matcher-grid">';
            
            // Services column
            html += '<div class="services-column">';
            gameData.services.forEach((service, index) => {
                const matched = gameData.matched.includes(`service-${index}`);
                html += `
                    <div class="service-card ${matched ? 'matched' : ''}" onclick="selectServiceCard('service', ${index})">
                        <div class="service-icon">${service.icon}</div>
                        <div class="service-name">${service.name}</div>
                    </div>
                `;
            });
            html += '</div>';
            
            // Descriptions column
            html += '<div class="descriptions-column">';
            const shuffledDescriptions = [...gameData.services].sort(() => Math.random() - 0.5);
            shuffledDescriptions.forEach((service, index) => {
                const matched = gameData.matched.includes(`desc-${index}`);
                html += `
                    <div class="description-card ${matched ? 'matched' : ''}" onclick="selectServiceCard('desc', ${index})">
                        <div class="service-description">${service.description}</div>
                    </div>
                `;
            });
            html += '</div>';
            
            html += '</div>';
            html += `<div class="game-stats">Matches: ${gameData.matched.length / 2}/${gameData.pairs} | Attempts: ${gameData.attempts}</div>`;
            
            container.innerHTML = html;
        }
        
        function selectServiceCard(type, index) {
            const gameData = challengeState.miniGameData;
            const cardId = `${type}-${index}`;
            
            if (gameData.matched.includes(cardId)) return;
            
            if (!gameData.selected) {
                gameData.selected = { type, index, cardId };
                document.querySelector(`[onclick="selectServiceCard('${type}', ${index})"]`).classList.add('selected');
            } else {
                gameData.attempts++;
                
                // Check if match
                const service1 = gameData.services[gameData.selected.type === 'service' ? gameData.selected.index : index];
                const service2 = gameData.services[gameData.selected.type === 'desc' ? gameData.selected.index : index];
                
                if (service1 === service2) {
                    // Match!
                    gameData.matched.push(gameData.selected.cardId, cardId);
                    addEffect(400, 300, 'MATCH!', '#00ff00', 20);
                    
                    if (gameData.matched.length >= gameData.pairs * 2) {
                        // Game complete
                        const score = Math.max(0, 1000 - (gameData.attempts * 50));
                        completeMiniGame(score);
                        return;
                    }
                } else {
                    // No match
                    addEffect(400, 300, 'TRY AGAIN', '#ff0044', 16);
                }
                
                gameData.selected = null;
                displayServiceMatcher();
            }
        }
        
        function initializeSnakeGame() {
            challengeState.miniGameData.snake = {
                x: 10,
                y: 10,
                dx: 0,
                dy: 0,
                cells: [],
                maxCells: 4
            };
            
            challengeState.miniGameData.food = {
                x: 15,
                y: 15,
                service: 'EC2'
            };
            
            challengeState.miniGameData.grid = 20;
            challengeState.miniGameData.score = 0;
            challengeState.miniGameData.gameLoop = null;
            
            displaySnakeGame();
            startSnakeGameLoop();
        }
        
        function displaySnakeGame() {
            const container = document.getElementById('mini-game-content');
            if (!container) return;
            
            const gameData = challengeState.miniGameData;
            
            container.innerHTML = `
                <div class="snake-game-container">
                    <div class="snake-score">Score: ${gameData.score}</div>
                    <canvas id="snake-canvas" width="400" height="400"></canvas>
                    <div class="snake-controls">
                        <div class="control-instructions">Use WASD or Arrow Keys to move</div>
                        <div class="snake-food">Collect: ${gameData.food.service}</div>
                    </div>
                </div>
            `;
            
            // Set up controls
            document.addEventListener('keydown', handleSnakeInput);
        }
        
        function handleSnakeInput(e) {
            if (!challengeState.miniGameActive || challengeState.miniGameData.id !== 'snake_game') return;
            
            const snake = challengeState.miniGameData.snake;
            
            // Prevent reverse direction
            if (e.key === 'ArrowLeft' || e.key === 'a') {
                if (snake.dx === 0) {
                    snake.dx = -1;
                    snake.dy = 0;
                }
            } else if (e.key === 'ArrowUp' || e.key === 'w') {
                if (snake.dy === 0) {
                    snake.dx = 0;
                    snake.dy = -1;
                }
            } else if (e.key === 'ArrowRight' || e.key === 'd') {
                if (snake.dx === 0) {
                    snake.dx = 1;
                    snake.dy = 0;
                }
            } else if (e.key === 'ArrowDown' || e.key === 's') {
                if (snake.dy === 0) {
                    snake.dx = 0;
                    snake.dy = 1;
                }
            }
        }
        
        function startSnakeGameLoop() {
            challengeState.miniGameData.gameLoop = setInterval(() => {
                updateSnakeGame();
                drawSnakeGame();
            }, 100);
        }
        
        function updateSnakeGame() {
            const gameData = challengeState.miniGameData;
            const snake = gameData.snake;
            
            // Move snake
            snake.x += snake.dx;
            snake.y += snake.dy;
            
            // Wrap around edges
            if (snake.x < 0) snake.x = gameData.grid - 1;
            if (snake.x >= gameData.grid) snake.x = 0;
            if (snake.y < 0) snake.y = gameData.grid - 1;
            if (snake.y >= gameData.grid) snake.y = 0;
            
            // Keep track of where snake has been
            snake.cells.unshift({ x: snake.x, y: snake.y });
            
            // Remove cells as we move away from them
            if (snake.cells.length > snake.maxCells) {
                snake.cells.pop();
            }
            
            // Check food collision
            if (snake.x === gameData.food.x && snake.y === gameData.food.y) {
                snake.maxCells++;
                gameData.score += 10;
                
                // Generate new food
                const services = ['EC2', 'S3', 'RDS', 'Lambda', 'VPC', 'CloudFront'];
                gameData.food = {
                    x: Math.floor(Math.random() * gameData.grid),
                    y: Math.floor(Math.random() * gameData.grid),
                    service: services[Math.floor(Math.random() * services.length)]
                };
                
                // Update score display
                document.querySelector('.snake-score').textContent = `Score: ${gameData.score}`;
                document.querySelector('.snake-food').textContent = `Collect: ${gameData.food.service}`;
                
                // Check win condition
                if (gameData.score >= gameData.targetScore) {
                    clearInterval(gameData.gameLoop);
                    completeMiniGame(gameData.score);
                    return;
                }
            }
            
            // Check self collision
            for (let i = 1; i < snake.cells.length; i++) {
                if (snake.x === snake.cells[i].x && snake.y === snake.cells[i].y) {
                    // Game over
                    clearInterval(gameData.gameLoop);
                    completeMiniGame(gameData.score);
                    return;
                }
            }
            
            // Check time limit
            const elapsed = (Date.now() - gameData.startTime) / 1000;
            if (elapsed >= gameData.timeLimit) {
                clearInterval(gameData.gameLoop);
                completeMiniGame(gameData.score);
            }
        }
        
        function drawSnakeGame() {
            const canvas = document.getElementById('snake-canvas');
            if (!canvas) return;
            
            const context = canvas.getContext('2d');
            const gameData = challengeState.miniGameData;
            
            // Clear canvas
            context.fillStyle = 'var(--bg-darkest)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw food
            context.fillStyle = 'var(--pixel-yellow)';
            context.fillRect(gameData.food.x * 20, gameData.food.y * 20, 20, 20);
            
            // Draw snake
            context.fillStyle = 'var(--pixel-green)';
            gameData.snake.cells.forEach((cell, index) => {
                context.fillRect(cell.x * 20, cell.y * 20, 20, 20);
                
                // Draw snake head differently
                if (index === 0) {
                    context.fillStyle = 'var(--pixel-cyan)';
                    context.fillRect(cell.x * 20 + 2, cell.y * 20 + 2, 16, 16);
                    context.fillStyle = 'var(--pixel-green)';
                }
            });
        }
        
        function showMiniGameUI() {
            const miniGamePanel = document.getElementById('mini-game-panel');
            if (miniGamePanel) {
                miniGamePanel.style.display = 'block';
                miniGamePanel.classList.add('active');
            }
        }
        
        function hideMiniGameUI() {
            const miniGamePanel = document.getElementById('mini-game-panel');
            if (miniGamePanel) {
                miniGamePanel.style.display = 'none';
                miniGamePanel.classList.remove('active');
            }
            
            // Clean up event listeners
            document.removeEventListener('keydown', handleSnakeInput);
        }
        
        function showChallengeSelector() {
            const challengePanel = document.getElementById('challenge-panel');
            if (challengePanel) {
                challengePanel.style.display = 'block';
                challengePanel.classList.add('active');
                updateChallengeList();
            }
        }
        
        function hideChallengeSelector() {
            const challengePanel = document.getElementById('challenge-panel');
            if (challengePanel) {
                challengePanel.style.display = 'none';
                challengePanel.classList.remove('active');
            }
        }
        
        function updateChallengeList() {
            const challengeList = document.getElementById('challenge-list');
            if (!challengeList) return;
            
            let html = '<div class="challenge-categories">';
            
            // Available challenges
            html += '<h3>Available Challenges</h3>';
            challengeState.availableChallenges.forEach(challenge => {
                const completed = challengeState.completedChallenges.includes(challenge.id);
                html += `
                    <div class="challenge-item ${completed ? 'completed' : ''}">
                        <div class="challenge-icon">${challenge.icon}</div>
                        <div class="challenge-info">
                            <div class="challenge-name">${challenge.name}</div>
                            <div class="challenge-description">${challenge.description}</div>
                            <div class="challenge-reward">Reward: ${challenge.reward.exp} EXP</div>
                        </div>
                        <button class="pixel-button" onclick="startChallenge('${challenge.id}')" ${completed ? 'disabled' : ''}>
                            ${completed ? 'Completed' : 'Start'}
                        </button>
                    </div>
                `;
            });
            
            // Mini-games
            html += '<h3>Mini-Games</h3>';
            Object.values(MINI_GAMES).forEach(miniGame => {
                const highScore = gameState.player.miniGameScores[miniGame.id] || 0;
                html += `
                    <div class="mini-game-item">
                        <div class="mini-game-icon">${miniGame.icon}</div>
                        <div class="mini-game-info">
                            <div class="mini-game-name">${miniGame.name}</div>
                            <div class="mini-game-description">${miniGame.description}</div>
                            <div class="mini-game-high-score">High Score: ${highScore}</div>
                        </div>
                        <button class="pixel-button" onclick="startMiniGame('${miniGame.id}')">
                            Play
                        </button>
                    </div>
                `;
            });
            
            html += '</div>';
            challengeList.innerHTML = html;
        }

        // Authentication UI Functions
        async function showLogin() {
            document.getElementById('welcome-screen').classList.add('hidden');
            document.getElementById('login-screen').classList.remove('hidden');
        }

        async function showRegister() {
            document.getElementById('welcome-screen').classList.add('hidden');
            document.getElementById('register-screen').classList.remove('hidden');
        }

        async function backToWelcome() {
            document.getElementById('login-screen').classList.add('hidden');
            document.getElementById('register-screen').classList.add('hidden');
            document.getElementById('welcome-screen').classList.remove('hidden');
        }

        async function performLogin() {
            const username = document.getElementById('login-username').value;
            const password = document.getElementById('login-password').value;
            
            if (!username || !password) {
                updateAuthStatus('Please enter username and password', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/auth/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username, password })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    gameState.userToken = data.token;
                    gameState.isAuthenticated = true;
                    localStorage.setItem('userToken', data.token);
                    
                    // Load progress
                    await initializeAuth();
                    
                    updateAuthStatus(`Welcome back, ${data.user.username}!`, 'authenticated');
                    backToWelcome();
                    startAutoSave();
                    addNotification('Logged in successfully!', 'success');
                } else {
                    updateAuthStatus(data.error || 'Login failed', 'error');
                }
            } catch (error) {
                console.error('Login error:', error);
                updateAuthStatus('Network error', 'error');
            }
        }

        async function performRegister() {
            const username = document.getElementById('register-username').value;
            const email = document.getElementById('register-email').value;
            const password = document.getElementById('register-password').value;
            
            if (!username || !email || !password) {
                updateAuthStatus('Please fill all fields', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/auth/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username, email, password })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    gameState.userToken = data.token;
                    gameState.isAuthenticated = true;
                    localStorage.setItem('userToken', data.token);
                    
                    updateAuthStatus(`Account created! Welcome, ${data.user.username}!`, 'authenticated');
                    backToWelcome();
                    startAutoSave();
                    addNotification('Account created successfully!', 'success');
                } else {
                    updateAuthStatus(data.error || 'Registration failed', 'error');
                }
            } catch (error) {
                console.error('Register error:', error);
                updateAuthStatus('Network error', 'error');
            }
        }

        function updateAuthStatus(message, type = 'info') {
            const authStatus = document.getElementById('auth-status');
            const authMessage = document.getElementById('auth-message');
            
            authMessage.textContent = message;
            authStatus.className = `auth-status ${type}`;
            
            setTimeout(() => {
                if (type === 'error') {
                    authStatus.className = 'auth-status';
                    authMessage.textContent = gameState.isAuthenticated 
                        ? 'Logged in - Progress auto-saved' 
                        : 'Play as guest or login to save progress';
                }
            }, 3000);
        }

        // Enhanced battle functions to trigger saves
        function triggerSave() {
            if (gameState.isAuthenticated) {
                saveGameProgress();
            }
        }

        // SIMPLIFIED EVENT SYSTEM - GUARANTEED TO WORK
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 AWS Quest Loading...');
            
            // Wait for DOM to be fully ready
            setTimeout(() => {
                console.log('🔧 Setting up button system...');
                setupButtons();
            }, 100);
            
            // Initialize game
            initializeGame();
            
            // Event delegation approach - attach to document body
            document.body.addEventListener('click', function(e) {
                console.log('Click detected on:', e.target.id, e.target.className);
                
                // Handle button clicks
                if (e.target.id === 'start-adventure-btn') {
                    console.log('✅ Start Adventure clicked via delegation');
                    e.preventDefault();
                    e.stopPropagation();
                    startBattle();
                }
                
                if (e.target.id === 'show-levels-btn') {
                    console.log('✅ Show Levels clicked via delegation');
                    e.preventDefault();
                    e.stopPropagation();
                    showLevelSelection();
                }
                
                if (e.target.id === 'show-components-btn') {
                    console.log('✅ Show Components clicked via delegation');
                    e.preventDefault();
                    e.stopPropagation();
                    showComponentsScreen();
                }
                
                if (e.target.id === 'back-to-menu-btn') {
                    console.log('✅ Back to Menu clicked via delegation');
                    e.preventDefault();
                    e.stopPropagation();
                    backToMenu();
                }
                
                if (e.target.id === 'attack-btn') {
                    console.log('✅ Attack clicked via delegation');
                    e.preventDefault();
                    e.stopPropagation();
                    attack();
                }
                
                if (e.target.id === 'next-battle-btn') {
                    console.log('✅ Next Battle clicked via delegation');
                    e.preventDefault();
                    e.stopPropagation();
                    nextBattle();
                }
                
                // Handle pixel options
                if (e.target.classList.contains('pixel-option')) {
                    const index = parseInt(e.target.dataset.option);
                    console.log('✅ Option', index, 'clicked via delegation');
                    e.preventDefault();
                    e.stopPropagation();
                    selectOption(index);
                }
            });
            
            // Force all buttons to be clickable
            document.querySelectorAll('.pixel-button, .pixel-option').forEach(btn => {
                btn.style.pointerEvents = 'auto';
                btn.style.zIndex = '1000';
                btn.style.position = 'relative';
            });
            
            // Backup direct event listeners for debugging
            const startBtn = document.getElementById('start-adventure-btn');
            const levelsBtn = document.getElementById('show-levels-btn');
            const componentsBtn = document.getElementById('show-components-btn');
            const backBtn = document.getElementById('back-to-menu-btn');
            const attackBtn = document.getElementById('attack-btn');
            const nextBtn = document.getElementById('next-battle-btn');
            
            if (startBtn) {
                startBtn.style.pointerEvents = 'auto';
                startBtn.style.zIndex = '1000';
                startBtn.addEventListener('click', function(e) {
                    console.log('Start button clicked');
                    e.preventDefault();
                    e.stopPropagation();
                    startBattle();
                });
                console.log('✅ Start button event listener attached');
            } else {
                console.error('❌ Start button not found');
            }
            
            if (levelsBtn) {
                levelsBtn.addEventListener('click', function(e) {
                    console.log('Levels button clicked');
                    e.preventDefault();
                    showLevelSelection();
                });
            } else {
                console.error('Levels button not found');
            }
            
            if (componentsBtn) {
                componentsBtn.addEventListener('click', function(e) {
                    console.log('Components button clicked');
                    e.preventDefault();
                    showComponentsScreen();
                });
            } else {
                console.error('Components button not found');
            }
            
            if (backBtn) {
                backBtn.addEventListener('click', function(e) {
                    console.log('Back button clicked');
                    e.preventDefault();
                    backToMenu();
                });
            } else {
                console.error('Back button not found');
            }
            
            if (attackBtn) {
                attackBtn.addEventListener('click', function(e) {
                    console.log('Attack button clicked');
                    e.preventDefault();
                    attack();
                });
            } else {
                console.error('Attack button not found');
            }
            
            if (nextBtn) {
                nextBtn.addEventListener('click', function(e) {
                    console.log('Next button clicked');
                    e.preventDefault();
                    nextBattle();
                });
            } else {
                console.error('Next button not found');
            }
            
            // Auth event listeners with null checks
            const showLoginBtn = document.getElementById('show-login-btn');
            const showRegisterBtn = document.getElementById('show-register-btn');
            const loginSubmitBtn = document.getElementById('login-submit-btn');
            const registerSubmitBtn = document.getElementById('register-submit-btn');
            const backFromLoginBtn = document.getElementById('back-from-login-btn');
            const backFromRegisterBtn = document.getElementById('back-from-register-btn');
            const backFromComponentsBtn = document.getElementById('back-from-components-btn');
            
            if (showLoginBtn) {
                showLoginBtn.addEventListener('click', function(e) {
                    console.log('Show login button clicked');
                    e.preventDefault();
                    showLogin();
                });
            } else {
                console.error('Show login button not found');
            }
            
            if (showRegisterBtn) {
                showRegisterBtn.addEventListener('click', function(e) {
                    console.log('Show register button clicked');
                    e.preventDefault();
                    showRegister();
                });
            } else {
                console.error('Show register button not found');
            }
            
            if (loginSubmitBtn) {
                loginSubmitBtn.addEventListener('click', function(e) {
                    console.log('Login submit button clicked');
                    e.preventDefault();
                    performLogin();
                });
            } else {
                console.error('Login submit button not found');
            }
            
            if (registerSubmitBtn) {
                registerSubmitBtn.addEventListener('click', function(e) {
                    console.log('Register submit button clicked');
                    e.preventDefault();
                    performRegister();
                });
            } else {
                console.error('Register submit button not found');
            }
            
            if (backFromLoginBtn) {
                backFromLoginBtn.addEventListener('click', function(e) {
                    console.log('Back from login button clicked');
                    e.preventDefault();
                    backToWelcome();
                });
            } else {
                console.error('Back from login button not found');
            }
            
            if (backFromRegisterBtn) {
                backFromRegisterBtn.addEventListener('click', function(e) {
                    console.log('Back from register button clicked');
                    e.preventDefault();
                    backToWelcome();
                });
            } else {
                console.error('Back from register button not found');
            }
            
            if (backFromComponentsBtn) {
                backFromComponentsBtn.addEventListener('click', function(e) {
                    console.log('Back from components button clicked');
                    e.preventDefault();
                    backFromComponents();
                });
            } else {
                console.error('Back from components button not found');
            }
            
            // Option selection listeners with debugging
            const pixelOptions = document.querySelectorAll('.pixel-option');
            console.log('Found', pixelOptions.length, 'pixel options');
            
            pixelOptions.forEach((option, index) => {
                option.style.pointerEvents = 'auto';
                option.style.zIndex = '1000';
                option.addEventListener('click', function(e) {
                    console.log('Option', index, 'clicked');
                    e.preventDefault();
                    e.stopPropagation();
                    selectOption(index);
                });
            });
            
            // Keyboard controls with debugging
            document.addEventListener('keydown', function(e) {
                console.log('Key pressed:', e.key, 'In battle:', gameState.isInBattle);
                
                switch(e.key) {
                    case '1':
                    case '2': 
                    case '3':
                    case '4':
                        if (gameState.isInBattle) {
                            const optionIndex = parseInt(e.key) - 1;
                            if (optionIndex < 4) {
                                console.log('Selecting option via keyboard:', optionIndex);
                                selectOption(optionIndex);
                            }
                        }
                        break;
                    case 'Enter':
                    case ' ':
                        const attackBtnElement = document.getElementById('attack-btn');
                        if (gameState.isInBattle && attackBtnElement && !attackBtnElement.disabled) {
                            console.log('Attacking via keyboard');
                            attack();
                        }
                        break;
                }
            });
            
            // Final check: Make sure all buttons are clickable
            setTimeout(() => {
                document.querySelectorAll('.pixel-button, .pixel-option').forEach(btn => {
                    btn.style.pointerEvents = 'auto';
                    btn.style.zIndex = '1000';
                    btn.style.position = 'relative';
                });
                console.log('🔧 All buttons forced to be clickable');
            }, 500);
            
            console.log('✅ AWS Quest Ready!');
        });
        
        // GUARANTEED BUTTON SETUP FUNCTION
        function setupButtons() {
            console.log('🔧 Setting up buttons...');
            
            // Clear any existing onclick handlers
            const buttons = document.querySelectorAll('.pixel-button, .pixel-option');
            buttons.forEach(btn => {
                btn.onclick = null;
            });
            
            // Add new event listeners
            const startBtn = document.getElementById('start-adventure-btn');
            const levelsBtn = document.getElementById('show-levels-btn');
            const componentsBtn = document.getElementById('show-components-btn');
            const loginBtn = document.getElementById('show-login-btn');
            
            if (startBtn) {
                startBtn.onclick = function(e) {
                    console.log('✅ START GAME CLICKED!');
                    e.preventDefault();
                    startBattle();
                };
                console.log('✅ Start button setup complete');
            } else {
                console.error('❌ Start button not found');
            }
            
            if (levelsBtn) {
                levelsBtn.onclick = function(e) {
                    console.log('✅ LEVELS CLICKED!');
                    e.preventDefault();
                    showLevelSelection();
                };
                console.log('✅ Levels button setup complete');
            } else {
                console.error('❌ Levels button not found');
            }
            
            if (componentsBtn) {
                componentsBtn.onclick = function(e) {
                    console.log('✅ COMPONENTS CLICKED!');
                    e.preventDefault();
                    showComponentsScreen();
                };
                console.log('✅ Components button setup complete');
            } else {
                console.error('❌ Components button not found');
            }
            
            if (loginBtn) {
                loginBtn.onclick = function(e) {
                    console.log('✅ LOGIN CLICKED!');
                    e.preventDefault();
                    showLogin();
                };
                console.log('✅ Login button setup complete');
            } else {
                console.error('❌ Login button not found');
            }
            
            // Force all buttons to be visible and clickable
            document.querySelectorAll('.pixel-button, .pixel-option').forEach(btn => {
                btn.style.pointerEvents = 'auto';
                btn.style.zIndex = '9999';
                btn.style.position = 'relative';
                btn.style.display = 'inline-block';
                btn.style.cursor = 'pointer';
                btn.style.opacity = '1';
                btn.style.visibility = 'visible';
            });
            
            console.log('🎯 All buttons are now ready!');
        }
    </script>
</body>
</html>
